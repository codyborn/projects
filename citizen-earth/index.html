<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, orientation=portrait">
  <title>Citizen Earth</title>
  <style>
    html, body {
      height: 100%;
    }
    body {
      background: #4DD0E1;
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    #water-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      pointer-events: none;
      display: block;
    }
    #cloud-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 4;
      pointer-events: none;
      display: block;
    }
    #boat-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 3;
      pointer-events: none;
      display: block;
    }
    h1 {
      text-align: center;
      margin-top: 32px;
      font-size: 2.5rem;
      color: #222;
      z-index: 5;
      position: relative;
    }
    .island-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      max-width: 1200px;
      margin-top: 40px;
      margin-bottom: 0px;
      margin-left: auto;
      margin-right: auto;

      direction: ltr;
    }
    .island-row {
      display: contents;
    }
    .island {
      display: flex;
      flex-direction: column;
      align-items: center;
      border-radius: 18px;
      padding: 16px 8px 8px 8px;
      transition: transform 0.2s;
      cursor: pointer;
    }

    .island img {
      width: 120px;
      height: auto;
      margin-bottom: 12px;
      border-radius: 12px;
    }
    .city-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2a4d69;
      text-align: center;
      position: relative;
      z-index: 5;
    }
    @media (max-width: 900px) {
      .island-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 600px) {
      html {
        scroll-snap-type: y mandatory;
        scroll-behavior: smooth;
      }
      body {
        scroll-snap-type: y mandatory;
      }
      .island-grid {
        grid-template-columns: 1fr !important;
        justify-items: center;
        gap: 10vh;
        padding: 0 20px;
      }
      .island {
        grid-area: auto !important;
        scroll-snap-align: center;
        scroll-snap-stop: always;
        
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
    }
    .island-tooltip {
      background: rgba(44, 62, 80, 0.97);
      color: #fff;
      padding: 10px 16px;
      border-radius: 5px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.18);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
      z-index: 10;
      font-size: 1rem;
      margin-top: 1.5em;
    }
    .island {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .island-tooltip a {
      color: #ffd700;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <canvas id="water-canvas"></canvas>
  <canvas id="cloud-canvas"></canvas>
  <canvas id="boat-canvas"></canvas>
  <h1>Citizen Earth</h1>
  <div class="island-grid" style="position:relative; z-index:2;">
    <!-- Islands will be inserted here by JS -->
  </div>
  <svg id="island-lines" style="position:absolute; top:0; left:0; pointer-events:none; z-index:1;"></svg>
  <script>
    // Lock orientation to portrait on mobile devices
    if (window.innerWidth <= 600 && screen.orientation && screen.orientation.lock) {
      screen.orientation.lock('portrait').catch(() => {
        // Orientation lock not supported or failed
        console.log('Orientation lock not supported');
      });
    }

    // Water effect
    const waveHeight = 10;
    const waveLength = 200;
    const speed = 0.0002;
    const waterCanvas = document.getElementById('water-canvas');
    const ctx = waterCanvas.getContext('2d');
    
    // Pre-calculate random values for consistent wave colors
    let randomValues = [];
    
    // Cloud system
    const cloudImage = new Image();
    cloudImage.src = './images/cloud.png';
    let clouds = [];
    const cloudSpeed = 0.1; // pixels per frame
    let islandBounds = []; // Store top and bottom Y values of each island
    const cloudSpawnProbability = 0.0004;
    
    // Sailboat system
    const sailboatImage = new Image();
    sailboatImage.src = './images/sailboat.png';
    let sailboats = [];
    const sailboatSpawnProbability = 0.002; // Reasonable spawn rate

    function checkSailboatOverlap(sailboatX, sailboatY, sailboatSize) {
      if (!sailboatImage.complete) return false;
      
      const sailboatWidth = sailboatImage.width * sailboatSize;
      const sailboatHeight = sailboatImage.height * sailboatSize;
      const sailboatBottom = sailboatY + sailboatHeight;
      const sailboatRight = sailboatX + sailboatWidth;
      
      // Check if sailboat overlaps with any island
      for (let island of islandBounds) {
        if (sailboatX < island.right && sailboatRight > island.left &&
            sailboatY < island.bottom && sailboatBottom > island.top) {
          return true; // Overlap detected
        }
      }
      return false; // No overlap
    }
    
    function getValidSailboatPosition(sailboatSize) {
      const maxAttempts = 50; // More attempts since we're checking X and Y
      let attempts = 0;
      
      while (attempts < maxAttempts) {
        const randomX = Math.random() * boatCanvas.width;
        const randomY = Math.random() * boatCanvas.height; // Use full canvas height
        
        if (!checkSailboatOverlap(randomX, randomY, sailboatSize)) {
          return { x: randomX, y: randomY };
        }
        attempts++;
      }
      
      // If no valid position found, place at edge of screen
      const fallbackPositions = [
        { x: 50, y: boatCanvas.height * 0.2 },
        { x: boatCanvas.width - 100, y: boatCanvas.height * 0.4 },
        { x: boatCanvas.width * 0.5, y: boatCanvas.height * 0.6 },
        { x: 100, y: boatCanvas.height * 0.8 },
        { x: boatCanvas.width - 150, y: boatCanvas.height * 0.9 }
      ];
      
      // Try each fallback position
      for (let pos of fallbackPositions) {
        if (!checkSailboatOverlap(pos.x, pos.y, sailboatSize)) {
          return pos;
        }
      }
      
      // Last resort: place at safe edge position
      return { 
        x: Math.random() > 0.5 ? 50 : boatCanvas.width - 100, 
        y: Math.random() * boatCanvas.height // Use full canvas height
      };
    }
    
    function initializeSailboats() {
      sailboats = [];
      
      // Start with 2 sailboats on the page
      for (let i = 0; i < 2; i++) {
        const size = 0.4;
        const direction = Math.random() > 0.5 ? 1 : -1;
        sailboats.push({
          x: Math.random() * boatCanvas.width,
          y: Math.random() * boatCanvas.height,
          size: size,
          speedX: (0.1 + Math.random() * 0.1) * direction,
          speedY: (Math.random() - 0.5) * 0.05,
          stopped: false,
          stopTimer: 0,
          originalSpeedX: (0.1 + Math.random() * 0.1) * direction,
          bobbingPhase: Math.random() * Math.PI * 2
        });
      }
    }

    // Cloud canvas setup
    const cloudCanvas = document.getElementById('cloud-canvas');
    const cloudCtx = cloudCanvas.getContext('2d');
    
    function resizeCloudCanvas() {      
      cloudCanvas.width = Math.max(document.documentElement.scrollWidth, window.innerWidth);
      cloudCanvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight, document.body.offsetHeight);
    }
    
    // Boat canvas setup
    const boatCanvas = document.getElementById('boat-canvas');
    const boatCtx = boatCanvas.getContext('2d');
    
    function resizeBoatCanvas() {      
      boatCanvas.width = Math.max(document.documentElement.scrollWidth, window.innerWidth);
      boatCanvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight, document.body.offsetHeight);
    }
    
    function updateIslandBounds() {
      islandBounds = [];
      const islands = document.querySelectorAll('.island img');
      islands.forEach(img => {
        const rect = img.getBoundingClientRect();
        islandBounds.push({
          top: rect.top + window.scrollY,
          bottom: rect.bottom + window.scrollY,
          left: rect.left + window.scrollX,
          right: rect.right + window.scrollX
        });
      });
    }
    
    function initializeClouds() {
      clouds = [];
      const cloudCount = 5;
      for (let i = 0; i < cloudCount; i++) {
        const size = 0.3 + Math.random() * 0.5;
        const x = Math.random() * cloudCanvas.width;
        clouds.push({
          x: x,
          y: Math.random() * cloudCanvas.height, // Use full canvas height
          size: size,
        });
      }
    }
    
    function updateClouds() {
      // Random chance to spawn a new cloud each frame
      if (Math.random() < cloudSpawnProbability) {
        spawnNewCloud();
      }
      
      // Update existing clouds and remove those that have exited
      for (let i = clouds.length - 1; i >= 0; i--) {
        const cloud = clouds[i];
        cloud.x -= cloudSpeed;
        
        // Remove cloud if it has completely exited the left side
        if (cloud.x + cloudImage.width * cloud.size < 0) {
          clouds.splice(i, 1); // Delete the cloud
        }
      }
    }
    
    function drawClouds() {
      cloudCtx.clearRect(0, 0, cloudCanvas.width, cloudCanvas.height);
      
      if (cloudImage.complete) {
        clouds.forEach(cloud => {
          cloudCtx.save();
          cloudCtx.globalAlpha = 1.0;
          cloudCtx.drawImage(
            cloudImage,
            cloud.x,
            cloud.y,
            cloudImage.width * cloud.size,
            cloudImage.height * cloud.size
          );
          cloudCtx.restore();
        });
      }
    }
    
    function animateClouds() {
      updateClouds();
      drawClouds();
      requestAnimationFrame(animateClouds);
    }
    
    function animateBoats() {
      updateSailboats();
      drawSailboats();
      requestAnimationFrame(animateBoats);
    }
    
    function generateRandomValues() {
      randomValues = [];
      for (let y = 0; y < waterCanvas.height; y += 20) {
        randomValues.push((Math.random() - 0.5) * 0.2); // Â±20% variance
      }
    }
    
    function resizeWaterCanvas() {      
      waterCanvas.width = Math.max(document.documentElement.scrollWidth, window.innerWidth);
      waterCanvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight, document.body.offsetHeight);
      generateRandomValues(); // Regenerate random values when canvas size changes
    }
    
    function updateAllCanvasSizes() {
      resizeWaterCanvas();
      resizeCloudCanvas(); 
      resizeBoatCanvas();
    }
    updateAllCanvasSizes();
    
    function drawWater(time) {
      ctx.clearRect(0, 0, waterCanvas.width, waterCanvas.height);
      // Base water color - teal/turquoise
      ctx.fillStyle = '#4DD0E1';
      ctx.fillRect(0, 0, waterCanvas.width, waterCanvas.height);
      
      // Draw subtle crescent wave lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineCap = 'round';
      
      for (let i = 0; i < 15; i++) {
        ctx.beginPath();
        ctx.lineWidth = 2;
        
        // Create crescent shapes at different positions with independent movement
        const baseY = (i * 80) ;
        const rockingSpeed = 0.0003 + (i * 0.0001); // Each crescent has different rocking speed
        const rockingAmplitude = 5 + (i * 10); // Different rocking distances
        // Distribute crescents across the full width with some randomness
        const baseX = (i / 15) * waterCanvas.width + Math.sin(i * 1.7) * (waterCanvas.width * 0.2);
        const xCenter = baseX + Math.sin(time * rockingSpeed) * rockingAmplitude;
        const crescentWidth = 20 + Math.sin(i * 0.3) * 2;
        const crescentHeight = 3 + Math.sin(i * 0.7) * .7;
        
        // Draw crescent curve with shadow for dimension
        const alpha = 0.2 + Math.sin(i * 0.5 + time * 0.001) * 0.1;
        
        // First draw the shadow (darker, offset down)
        ctx.beginPath();
        for (let t = -Math.PI * 0.4; t <= Math.PI * 0.4; t += 0.05) {
          const x = xCenter + Math.sin(t) * crescentWidth;
          const y = baseY + Math.cos(t * 2) * crescentHeight + 2; // Offset shadow down by 2px
          
          if (t === -Math.PI * 0.4) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.strokeStyle = `rgba(0, 50, 80, ${alpha * 0.6})`; // Dark blue-gray shadow
        ctx.stroke();
        
        // Then draw the main line (white, on top)
        ctx.beginPath();
        for (let t = -Math.PI * 0.4; t <= Math.PI * 0.4; t += 0.05) {
          const x = xCenter + Math.sin(t) * crescentWidth;
          const y = baseY + Math.cos(t * 2) * crescentHeight;
          
          if (t === -Math.PI * 0.4) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.lineWidth = 4;
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.stroke();
      }
      
      requestAnimationFrame(drawWater);
    }
    requestAnimationFrame(drawWater);
    
    // Start cloud animation
    requestAnimationFrame(animateClouds);
    
    // Start boat animation
    requestAnimationFrame(animateBoats);

    // Placeholder cities with metadata
    const cities = [
      { 
        name: 'Miami',
        dates: 'Jan - Apr',
        islandImg: './images/miami.png',
        link: 'https://mirror.xyz/citizenearth.eth/mdQHEpgT3U0ZLge1NOm4xoMebfHwoaREPSYK3GIOdSc',
        linkText: 'Tied down'
      },
      { 
        name: 'New York', 
        dates: 'Apr', 
        islandImg: './images/NY.png',
        size: 200
      },
      { 
        name: 'Madrid', 
        dates: 'Apr - May', 
        islandImg: './images/madrid.png' ,
        size: 150
      },
      { 
        name: 'Granada', 
        dates: 'May', 
        islandImg: './images/granada.png' ,
        size: 200
      },
      { 
        name: 'Marseille', 
        dates: 'May',
        islandImg: './images/marseille.png' ,
        size: 160
      },
      { 
        name: 'Hyeres', 
        dates: 'May - Jun', 
        islandImg: './images/hyeres.png' 
      },
      { 
        name: 'Antibes', 
        dates: 'Jun', 
        islandImg: './images/antibes.png',
        size: 160
      },
    ];

    // Responsive grid: let CSS handle columns, JS figures out columns dynamically
    const grid = document.querySelector('.island-grid');
    const svg = document.getElementById('island-lines');
    function getColumnCount() {
      const style = window.getComputedStyle(grid);
      const templateColumns = style.getPropertyValue('grid-template-columns');
      return templateColumns.split(' ').length;
    }
    
    function renderIslands() {
      grid.innerHTML = '';
      const cols = getColumnCount();
      const rows = Math.ceil(cities.length / cols);
      const positions = [];
      cities.forEach((cityObj, i) => {
        const row = Math.floor(i / cols);
        let col = i % cols;
        if (row % 2 === 1) col = cols - 1 - col;
        const div = document.createElement('div');
        div.className = 'island';
        div.style.gridRow = (row + 1).toString();
        div.style.gridColumn = (col + 1).toString();
        div.innerHTML = `
          <img src="${cityObj.islandImg}" alt="Floating Island for ${cityObj.name}" style="width: ${cityObj.size ? cityObj.size + 'px' : '120px'}; height: auto;">
          <div class="city-name">${cityObj.name}</div>
          <div class="island-tooltip">
            <div><strong>${cityObj.name}</strong></div>
            <div>${cityObj.dates}</div>
            ${cityObj.link ? `<div><a href="${cityObj.link}" target="_blank">${cityObj.linkText}</a></div>` : ''}
          </div>
        `;
        positions.push({row, col, div});
        // Tooltip show/hide
        div.addEventListener('mouseenter', () => {
          div.querySelector('.island-tooltip').style.opacity = 1;
        });
        div.addEventListener('mouseleave', () => {
          div.querySelector('.island-tooltip').style.opacity = 0;
        });
        grid.appendChild(div);
      });
      setTimeout(updateIslandBounds, 100); // Update island bounds after layout is complete
      setTimeout(() => {
        updateAllCanvasSizes(); // Update canvas sizes after content is rendered
        initializeClouds();
        initializeSailboats();
        drawLines(positions, cols, rows);
        setupMobileTooltips(); // Setup mobile tooltip auto-display
      }, 300); // Increased delay to ensure content is fully rendered
    }
    function drawLines(positions, cols, rows) {
      svg.innerHTML = '';
      svg.setAttribute('width', document.body.scrollWidth);
      svg.setAttribute('height', document.body.scrollHeight);
      // Get center positions of each island image
      const centers = positions.map(({div}) => {
        const img = div.querySelector('img');
        const rect = img.getBoundingClientRect();
        return {
          x: rect.left + rect.width/2 + window.scrollX,
          y: rect.top + rect.height/2 + window.scrollY
        };
      });
      for (let i = 0; i < centers.length - 1; i++) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', centers[i].x);
        line.setAttribute('y1', centers[i].y);
        line.setAttribute('x2', centers[i+1].x);
        line.setAttribute('y2', centers[i+1].y);
        line.setAttribute('stroke', 'rgba(255, 255, 255, 0.5)');
        line.setAttribute('stroke-width', '4');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('stroke-dasharray', '8,8');
        svg.appendChild(line);
      }
    }
    // Set grid-template-columns to be responsive
    grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(180px, 1fr))';
    window.addEventListener('resize', renderIslands);
    renderIslands();

    // Mobile tooltip auto-display functionality
    function setupMobileTooltips() {
      // Check if device is mobile
      const isMobile = window.innerWidth <= 600;
      if (!isMobile) return;

      const islands = document.querySelectorAll('.island');
      const firstIsland = islands[0];
      const lastIsland = islands[islands.length - 1];

      // Create intersection observer for center screen detection
      const observerOptions = {
        root: null,
        rootMargin: '-40% 0px -40% 0px', // Only trigger when in center 20% of screen
        threshold: 0.5
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const tooltip = entry.target.querySelector('.island-tooltip');
          if (entry.isIntersecting) {
            // Island is in center area - show tooltip
            tooltip.style.opacity = '1';
            tooltip.style.transform = 'translateY(-10px)';
          } else {
            // Island is outside center area - hide tooltip
            tooltip.style.opacity = '0';
            tooltip.style.transform = 'translateY(0)';
          }
        });
      }, observerOptions);

      // Observe all islands
      islands.forEach(island => {
        observer.observe(island);
      });

      // Handle scroll for first/last island edge cases
      function handleScroll() {
        const scrollY = window.scrollY;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        
        // Show first island tooltip when at top of page
        if (scrollY <= 50) { // Within 50px of top
          const firstTooltip = firstIsland.querySelector('.island-tooltip');
          firstTooltip.style.opacity = '1';
          firstTooltip.style.transform = 'translateY(-10px)';
        }
        
        // Show last island tooltip when at bottom of page
        if (scrollY + windowHeight >= documentHeight - 50) { // Within 50px of bottom
          const lastTooltip = lastIsland.querySelector('.island-tooltip');
          lastTooltip.style.opacity = '1';
          lastTooltip.style.transform = 'translateY(-10px)';
        }
      }

      // Add scroll listener
      window.addEventListener('scroll', handleScroll);
      
      // Initial check
      handleScroll();
    }

    function updateSailboats() {
      // Random chance to spawn a new sailboat each frame
      if (Math.random() < sailboatSpawnProbability) {
        spawnNewSailboat();
      }
      
      // Update existing sailboats and remove those that have exited
      for (let i = sailboats.length - 1; i >= 0; i--) {
        const sailboat = sailboats[i];
        
        if (sailboat.stopped) {
          // Boat is stopped at island - only bob up and down
          sailboat.stopTimer++;
          sailboat.y += Math.sin(sailboat.stopTimer * 0.03 + sailboat.bobbingPhase) * 0.02;
          
          // After 5 seconds, resume sailing
          if (sailboat.stopTimer >= 300) {
            sailboat.stopped = false;
            sailboat.stopTimer = 0;
            sailboat.speedX = -sailboat.originalSpeedX; // Reverse direction
            sailboat.speedY = (Math.random() - 0.5) * 0.05;
          }
        } else {
          // Normal sailing behavior
          const prevX = sailboat.x;
          const prevY = sailboat.y;
          
          // Update position
          sailboat.x += sailboat.speedX;
          sailboat.y += sailboat.speedY;
          
          // Check for collision with islands and stop if needed
          if (checkSailboatOverlap(sailboat.x, sailboat.y, sailboat.size)) {
            sailboat.x = prevX;
            sailboat.y = prevY;
            sailboat.stopped = true;
            sailboat.stopTimer = 0;
          }
          
          // Bounce off top and bottom edges
          if (sailboat.y < 0) {
            sailboat.y = 0;
            sailboat.speedY = Math.abs(sailboat.speedY);
          }
          if (sailboat.y + sailboatImage.height * sailboat.size > boatCanvas.height) {
            sailboat.y = boatCanvas.height - sailboatImage.height * sailboat.size;
            sailboat.speedY = -Math.abs(sailboat.speedY);
          }
        }
        
        // Remove sailboat if it has completely exited the screen
        if (sailboat.x + sailboatImage.width * sailboat.size < 0 || sailboat.x > boatCanvas.width) {
          sailboats.splice(i, 1);
        }
      }
    }
    
    function drawSailboats() {
      boatCtx.clearRect(0, 0, boatCanvas.width, boatCanvas.height);
      
      if (sailboatImage.complete) {
        // Sort sailboats by Y position (lower Y drawn first, higher Y drawn last = in front)
        const sortedSailboats = [...sailboats].sort((a, b) => a.y - b.y);
        
        sortedSailboats.forEach(sailboat => {
          boatCtx.save();
          // Flip image if moving left
          if (sailboat.speedX < 0) {
            boatCtx.scale(-1, 1);
            boatCtx.drawImage(
              sailboatImage,
              -(sailboat.x + sailboatImage.width * sailboat.size),
              sailboat.y,
              sailboatImage.width * sailboat.size,
              sailboatImage.height * sailboat.size
            );
          } else {
            boatCtx.drawImage(
              sailboatImage,
              sailboat.x,
              sailboat.y,
              sailboatImage.width * sailboat.size,
              sailboatImage.height * sailboat.size
            );
          }
          boatCtx.restore();
        });
      }
    }

    function spawnNewCloud() {
      const size = 0.3 + Math.random() * 0.5;
      const x = cloudCanvas.width + 50; // Start off-screen to the right
      clouds.push({
        x: x,
        y: Math.random() * cloudCanvas.height,
        size: size,
      });
    }

    function spawnNewSailboat() {
      // Only spawn if image is loaded
      if (!sailboatImage.complete) return;
      
      const size = 0.4;
      const direction = Math.random() > 0.5 ? 1 : -1; // Random left or right
      const boatWidth = sailboatImage.width * size;
      const x = direction === 1 ? -boatWidth : boatCanvas.width + boatWidth;
      
      sailboats.push({
        x: x,
        y: Math.random() * boatCanvas.height,
        size: size,
        speedX: (0.1 + Math.random() * 0.1) * direction,
        speedY: (Math.random() - 0.5) * 0.05,
        stopped: false,
        stopTimer: 0,
        originalSpeedX: (0.1 + Math.random() * 0.1) * direction,
        bobbingPhase: Math.random() * Math.PI * 2
      });
    }
  </script>
</body>
</html> 