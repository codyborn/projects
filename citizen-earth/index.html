<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Citizen Earth</title>
  <style>
    body {
      background: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    #water-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      pointer-events: none;
      display: block;
    }
    #cloud-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 4;
      pointer-events: none;
      display: block;
    }
    #boat-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 3;
      pointer-events: none;
      display: block;
    }
    h1 {
      text-align: center;
      margin-top: 32px;
      font-size: 2.5rem;
      color: #222;
    }
    .island-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      padding: 0px;
      max-width: 1200px;
      margin-top: 40px;
      margin-bottom: 0px;
      margin-left: auto;
      margin-right: auto;

      direction: ltr;
    }
    .island-row {
      display: contents;
    }
    .island {
      display: flex;
      flex-direction: column;
      align-items: center;
      border-radius: 18px;
      padding: 16px 8px 8px 8px;
      transition: transform 0.2s;
      cursor: pointer;
    }

    .island img {
      width: 120px;
      height: auto;
      margin-bottom: 12px;
      border-radius: 12px;
    }
    .city-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2a4d69;
      text-align: center;
    }
    @media (max-width: 900px) {
      .island-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 600px) {
      .island-grid {
        grid-template-columns: 1fr;
      }
    }
    .island-tooltip {
      background: rgba(44, 62, 80, 0.97);
      color: #fff;
      padding: 10px 16px;
      border-radius: 5px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.18);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
      font-size: 1rem;
      margin-top: 1.5em;
    }
    .island {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .island-tooltip a {
      color: #ffd700;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <canvas id="water-canvas"></canvas>
  <canvas id="cloud-canvas"></canvas>
  <canvas id="boat-canvas"></canvas>
  <h1>Citizen Earth</h1>
  <div class="island-grid" style="position:relative; z-index:2;">
    <!-- Islands will be inserted here by JS -->
  </div>
  <svg id="island-lines" style="position:absolute; top:0; left:0; width:100vw; height:100vh; pointer-events:none; z-index:1;"></svg>
  <script>
    // Water effect
    const waveHeight = 10;
    const waveLength = 200;
    const speed = 0.0002;
    const canvas = document.getElementById('water-canvas');
    const ctx = canvas.getContext('2d');
    
    // Pre-calculate random values for consistent wave colors
    let randomValues = [];
    
    // Cloud system
    const cloudImage = new Image();
    cloudImage.src = './images/cloud.png';
    let clouds = [];
    const cloudSpeed = 0.1; // pixels per frame
    let islandBounds = []; // Store top and bottom Y values of each island
    const cloudSpawnProbability = 0.0004;
    
    // Sailboat system
    const sailboatImage = new Image();
    sailboatImage.src = './images/sailboat.png';
    let sailboats = [];
    
    function checkCloudOverlap(cloudY, cloudSize) {
      // const islandBuffer = 10;
      // const cloudBottom = cloudY + (cloudImage.height * cloudSize);
      // // Check if cloud overlaps with any island
      // for (let island of islandBounds) {
      //   // Proper collision detection: cloud overlaps if it starts before island ends AND ends after island starts
      //   if (cloudY < island.bottom + islandBuffer && cloudBottom > island.top - islandBuffer) {
      //     return true; // Overlap detected
      //   }
      // }
      return false; // No overlap
    }

    function checkSailboatOverlap(sailboatX, sailboatY, sailboatSize) {
      if (!sailboatImage.complete) return false;
      
      const sailboatWidth = sailboatImage.width * sailboatSize;
      const sailboatHeight = sailboatImage.height * sailboatSize;
      const sailboatBottom = sailboatY + sailboatHeight;
      const sailboatRight = sailboatX + sailboatWidth;
      
      // Check if sailboat overlaps with any island
      for (let island of islandBounds) {
        if (sailboatX < island.right && sailboatRight > island.left &&
            sailboatY < island.bottom && sailboatBottom > island.top) {
          return true; // Overlap detected
        }
      }
      return false; // No overlap
    }
    
    function getValidSailboatPosition(sailboatSize) {
      const maxAttempts = 50; // More attempts since we're checking X and Y
      let attempts = 0;
      
      while (attempts < maxAttempts) {
        const randomX = Math.random() * boatCanvas.width;
        const randomY = Math.random() * (boatCanvas.height * 0.6) + (boatCanvas.height * 0.3); // Middle 60% of lower screen
        
        if (!checkSailboatOverlap(randomX, randomY, sailboatSize)) {
          return { x: randomX, y: randomY };
        }
        attempts++;
      }
      
      // If no valid position found, place at edge of screen
      const fallbackPositions = [
        { x: 50, y: boatCanvas.height * 0.8 },
        { x: boatCanvas.width - 100, y: boatCanvas.height * 0.8 },
        { x: boatCanvas.width * 0.5, y: boatCanvas.height * 0.9 },
        { x: 100, y: boatCanvas.height * 0.7 },
        { x: boatCanvas.width - 150, y: boatCanvas.height * 0.7 }
      ];
      
      // Try each fallback position
      for (let pos of fallbackPositions) {
        if (!checkSailboatOverlap(pos.x, pos.y, sailboatSize)) {
          return pos;
        }
      }
      
      // Last resort: place at safe edge position
      return { 
        x: Math.random() > 0.5 ? 50 : boatCanvas.width - 100, 
        y: boatCanvas.height * 0.8 
      };
    }
    
    function initializeSailboats() {
      sailboats = [];
      const sailboatCount = 4;
      for (let i = 0; i < sailboatCount; i++) {
        const size = .4; // Smaller than clouds
        const position = getValidSailboatPosition(size);
        const direction = Math.random() > 0.5 ? 1 : -1; // Random left or right
        sailboats.push({
          x: position.x,
          y: position.y,
          size: size,
          speedX: (0.1 + Math.random() * 0.1) * direction, // 0.3-0.7 speed left or right
          speedY: (Math.random() - 0.5) * 0.05, // Small vertical drift
          stopped: false,
          stopTimer: 0,
          originalSpeedX: (0.1 + Math.random() * 0.1) * direction, // Store original speed
          bobbingPhase: Math.random() * Math.PI * 2, // Random bobbing phase
          offscreenTimer: 0 // Track how long boat has been offscreen
        });
      }
    }

    // Cloud canvas setup
    const cloudCanvas = document.getElementById('cloud-canvas');
    const cloudCtx = cloudCanvas.getContext('2d');
    
    function resizeCloudCanvas() {
      cloudCanvas.width = window.innerWidth;
      cloudCanvas.height = window.innerHeight;
    }
    resizeCloudCanvas();
    window.addEventListener('resize', resizeCloudCanvas);
    
    // Boat canvas setup
    const boatCanvas = document.getElementById('boat-canvas');
    const boatCtx = boatCanvas.getContext('2d');
    
    function resizeBoatCanvas() {
      boatCanvas.width = window.innerWidth;
      boatCanvas.height = window.innerHeight;
    }
    resizeBoatCanvas();
    window.addEventListener('resize', resizeBoatCanvas);
    
    function updateIslandBounds() {
      islandBounds = [];
      const islands = document.querySelectorAll('.island img');
      islands.forEach(img => {
        const rect = img.getBoundingClientRect();
        islandBounds.push({
          top: rect.top + window.scrollY,
          bottom: rect.bottom + window.scrollY,
          left: rect.left + window.scrollX,
          right: rect.right + window.scrollX
        });
      });
    }
    
    function initializeClouds() {
      clouds = [];
      const cloudCount = 5;
      for (let i = 0; i < cloudCount; i++) {
        const size = 0.3 + Math.random() * 0.5;
        const x = Math.random() * cloudCanvas.width;
        clouds.push({
          x: x,
          y: Math.random() * (cloudCanvas.height * 0.7),
          size: size,
        });
      }
    }
    
    function updateClouds() {
      // Random chance to spawn a new cloud each frame
      if (Math.random() < cloudSpawnProbability) {
        spawnNewCloud();
      }
      
      // Update existing clouds and remove those that have exited
      for (let i = clouds.length - 1; i >= 0; i--) {
        const cloud = clouds[i];
        cloud.x -= cloudSpeed;
        
        // Remove cloud if it has completely exited the left side
        if (cloud.x + cloudImage.width * cloud.size < 0) {
          clouds.splice(i, 1); // Delete the cloud
        }
      }
    }
    
    function drawClouds() {
      cloudCtx.clearRect(0, 0, cloudCanvas.width, cloudCanvas.height);
      
      if (cloudImage.complete) {
        clouds.forEach(cloud => {
          cloudCtx.save();
          cloudCtx.globalAlpha = 1.0;
          cloudCtx.drawImage(
            cloudImage,
            cloud.x,
            cloud.y,
            cloudImage.width * cloud.size,
            cloudImage.height * cloud.size
          );
          cloudCtx.restore();
        });
      }
    }
    
    function animateClouds() {
      updateClouds();
      drawClouds();
      requestAnimationFrame(animateClouds);
    }
    
    function animateBoats() {
      updateSailboats();
      drawSailboats();
      requestAnimationFrame(animateBoats);
    }
    
    function generateRandomValues() {
      randomValues = [];
      for (let y = 0; y < canvas.height; y += 20) {
        randomValues.push((Math.random() - 0.5) * 0.2); // ±20% variance
      }
    }
    
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      generateRandomValues(); // Regenerate random values when canvas size changes
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    function drawWater(time) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Base water color - teal/turquoise
      ctx.fillStyle = '#4DD0E1';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw subtle crescent wave lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineCap = 'round';
      
      for (let i = 0; i < 15; i++) {
        ctx.beginPath();
        ctx.lineWidth = 2;
        
        // Create crescent shapes at different positions with independent movement
        const baseY = (i * 80) ;
        const rockingSpeed = 0.0003 + (i * 0.0001); // Each crescent has different rocking speed
        const rockingAmplitude = 5 + (i * 10); // Different rocking distances
        // Distribute crescents across the full width with some randomness
        const baseX = (i / 15) * canvas.width + Math.sin(i * 1.7) * (canvas.width * 0.2);
        const xCenter = baseX + Math.sin(time * rockingSpeed) * rockingAmplitude;
        const crescentWidth = 20 + Math.sin(i * 0.3) * 2;
        const crescentHeight = 3 + Math.sin(i * 0.7) * .7;
        
        // Draw crescent curve with shadow for dimension
        const alpha = 0.2 + Math.sin(i * 0.5 + time * 0.001) * 0.1;
        
        // First draw the shadow (darker, offset down)
        ctx.beginPath();
        for (let t = -Math.PI * 0.4; t <= Math.PI * 0.4; t += 0.05) {
          const x = xCenter + Math.sin(t) * crescentWidth;
          const y = baseY + Math.cos(t * 2) * crescentHeight + 2; // Offset shadow down by 2px
          
          if (t === -Math.PI * 0.4) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.strokeStyle = `rgba(0, 50, 80, ${alpha * 0.6})`; // Dark blue-gray shadow
        ctx.stroke();
        
        // Then draw the main line (white, on top)
        ctx.beginPath();
        for (let t = -Math.PI * 0.4; t <= Math.PI * 0.4; t += 0.05) {
          const x = xCenter + Math.sin(t) * crescentWidth;
          const y = baseY + Math.cos(t * 2) * crescentHeight;
          
          if (t === -Math.PI * 0.4) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.lineWidth = 4;
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.stroke();
      }
      
      requestAnimationFrame(drawWater);
    }
    requestAnimationFrame(drawWater);
    
    // Start cloud animation
    requestAnimationFrame(animateClouds);
    
    // Start boat animation
    requestAnimationFrame(animateBoats);

    // Placeholder cities with metadata
    const cities = [
      { 
        name: 'Miami',
        dates: 'Jan - Apr',
        islandImg: './images/miami.png',
        link: 'https://mirror.xyz/citizenearth.eth/mdQHEpgT3U0ZLge1NOm4xoMebfHwoaREPSYK3GIOdSc',
        linkText: 'Tied down'
      },
      { 
        name: 'New York', 
        dates: 'Apr', 
        islandImg: './images/NY.png',
        size: 200
      },
      { 
        name: 'Madrid', 
        dates: 'Apr - May', 
        islandImg: './images/madrid.png' ,
        size: 150
      },
      { 
        name: 'Granada', 
        dates: 'May', 
        islandImg: './images/granada.png' ,
        size: 200
      },
      { 
        name: 'Marseille', 
        dates: 'May',
        islandImg: './images/marseille.png' ,
        size: 160
      },
      { 
        name: 'Hyeres', 
        dates: 'May - Jun', 
        islandImg: './images/hyeres.png' 
      },
      { 
        name: 'Antibes', 
        dates: 'Jun', 
        islandImg: './images/antibes.png',
        size: 160
      },
    ];

    // Responsive grid: let CSS handle columns, JS figures out columns dynamically
    const grid = document.querySelector('.island-grid');
    const svg = document.getElementById('island-lines');
    function getColumnCount() {
      const style = window.getComputedStyle(grid);
      const templateColumns = style.getPropertyValue('grid-template-columns');
      return templateColumns.split(' ').length;
    }
    function renderIslands() {
      grid.innerHTML = '';
      const cols = getColumnCount();
      const rows = Math.ceil(cities.length / cols);
      const positions = [];
      cities.forEach((cityObj, i) => {
        const row = Math.floor(i / cols);
        let col = i % cols;
        if (row % 2 === 1) col = cols - 1 - col;
        const div = document.createElement('div');
        div.className = 'island';
        div.style.gridRow = (row + 1).toString();
        div.style.gridColumn = (col + 1).toString();
        div.innerHTML = `
          <img src="${cityObj.islandImg}" alt="Floating Island for ${cityObj.name}" style="width: ${cityObj.size ? cityObj.size + 'px' : '120px'}; height: auto;">
          <div class="city-name">${cityObj.name}</div>
          <div class="island-tooltip">
            <div><strong>${cityObj.name}</strong></div>
            <div>${cityObj.dates}</div>
            ${cityObj.link ? `<div><a href="${cityObj.link}" target="_blank">${cityObj.linkText}</a></div>` : ''}
          </div>
        `;
        positions.push({row, col, div});
        // Tooltip show/hide
        div.addEventListener('mouseenter', () => {
          div.querySelector('.island-tooltip').style.opacity = 1;
        });
        div.addEventListener('mouseleave', () => {
          div.querySelector('.island-tooltip').style.opacity = 0;
        });
        grid.appendChild(div);
      });
      setTimeout(updateIslandBounds, 100); // Update island bounds after layout is complete
      setTimeout(() => {
        initializeClouds();
        initializeSailboats();
        drawLines(positions, cols, rows);
      }, 150); // Initialize both clouds and sailboats after island bounds are ready
    }
    function drawLines(positions, cols, rows) {
      svg.innerHTML = '';
      svg.setAttribute('width', document.body.scrollWidth);
      svg.setAttribute('height', document.body.scrollHeight);
      // Get center positions of each island image
      const centers = positions.map(({div}) => {
        const img = div.querySelector('img');
        const rect = img.getBoundingClientRect();
        return {
          x: rect.left + rect.width/2 + window.scrollX,
          y: rect.top + rect.height/2 + window.scrollY
        };
      });
      for (let i = 0; i < centers.length - 1; i++) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', centers[i].x);
        line.setAttribute('y1', centers[i].y);
        line.setAttribute('x2', centers[i+1].x);
        line.setAttribute('y2', centers[i+1].y);
        line.setAttribute('stroke', '#2a4d69');
        line.setAttribute('stroke-width', '4');
        line.setAttribute('stroke-linecap', 'round');
        svg.appendChild(line);
      }
    }
    // Set grid-template-columns to be responsive
    grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(180px, 1fr))';
    window.addEventListener('resize', renderIslands);
    renderIslands();

    function updateSailboats() {
      // Safety check: ensure we always have the right number of boats
      while (sailboats.length < 4) {
        const size = 0.4;
        const position = getValidSailboatPosition(size);
        const direction = Math.random() > 0.5 ? 1 : -1;
        sailboats.push({
          x: position.x,
          y: position.y,
          size: size,
          speedX: (0.1 + Math.random() * 0.1) * direction,
          speedY: (Math.random() - 0.5) * 0.05,
          stopped: false,
          stopTimer: 0,
          originalSpeedX: (0.1 + Math.random() * 0.1) * direction,
          bobbingPhase: Math.random() * Math.PI * 2,
          offscreenTimer: 0
        });
      }
      
      sailboats.forEach(sailboat => {
        // Check if boat is offscreen (completely outside canvas bounds)
        const isOffscreen = (sailboat.x + sailboatImage.width * sailboat.size < 0) || 
                           (sailboat.x > boatCanvas.width) ||
                           (sailboat.y + sailboatImage.height * sailboat.size < 0) ||
                           (sailboat.y > boatCanvas.height);
        
        if (isOffscreen) {
          sailboat.offscreenTimer++;
          // If offscreen for more than 1 second (60 frames), respawn
          if (sailboat.offscreenTimer > 60) {
            const newPosition = getValidSailboatPosition(sailboat.size);
            sailboat.offscreenTimer = 0;
            sailboat.stopped = false;
            sailboat.stopTimer = 0;
            const direction = Math.random() > 0.5 ? 1 : -1;
            if (direction === 1) {
              sailboat.x = -sailboatImage.width;
            } else {
              sailboat.x = boatCanvas.width + sailboatImage.width;
            }
            sailboat.y = newPosition.y;
            sailboat.speedX = (0.1 + Math.random() * 0.1) * direction;
            sailboat.speedY = (Math.random() - 0.5) * 0.05;
            sailboat.originalSpeedX = sailboat.speedX;
          }
        } else {
          sailboat.offscreenTimer = 0; // Reset timer when boat is onscreen
        }
        
        if (sailboat.stopped) {
          // Boat is stopped at island - only bob up and down
          sailboat.stopTimer++;
          sailboat.y += Math.sin(sailboat.stopTimer * 0.03 + sailboat.bobbingPhase) * 0.02; // Gentle bobbing
          
          // After 10 seconds (600 frames at 60fps), resume sailing
          if (sailboat.stopTimer >= 600) {
            sailboat.stopped = false;
            sailboat.stopTimer = 0;
            sailboat.speedX = -sailboat.originalSpeedX; // Reverse direction
            sailboat.speedY = (Math.random() - 0.5) * 0.05; // New drift
            sailboat.originalSpeedX = sailboat.speedX; // Update stored speed
            
            // Move to a safe position away from islands
            let attempts = 0;
            while (attempts < 20 && checkSailboatOverlap(sailboat.x, sailboat.y, sailboat.size)) {
              // Move away from the collision
              sailboat.x += sailboat.speedX * 10; // Move further in the new direction
              sailboat.y += (Math.random() - 0.5) * 20; // Add some random vertical offset
              attempts++;
            }
            
            // If still stuck after attempts, respawn at a completely new location
            if (checkSailboatOverlap(sailboat.x, sailboat.y, sailboat.size)) {
              const newPosition = getValidSailboatPosition(sailboat.size);
              sailboat.x = newPosition.x;
              sailboat.y = newPosition.y;
            }
          }
        } else {
          // Normal sailing behavior
          // Store previous position
          const prevX = sailboat.x;
          const prevY = sailboat.y;
          
          // Update position
          sailboat.x += sailboat.speedX;
          sailboat.y += sailboat.speedY;
          
          // Check for collision with islands and stop if needed
          if (checkSailboatOverlap(sailboat.x, sailboat.y, sailboat.size)) {
            // Revert to previous position and stop
            sailboat.x = prevX;
            sailboat.y = prevY;
            sailboat.stopped = true;
            sailboat.stopTimer = 0;
          }
        }
        
        // Wrap around screen edges (only if not stopped)
        if (!sailboat.stopped) {          
          // Keep sailboats in lower portion of screen
          if (sailboat.y < boatCanvas.height * 0.2) {
            sailboat.y = boatCanvas.height * 0.2;
            sailboat.speedY = Math.abs(sailboat.speedY); // Move down
          }
          if (sailboat.y + sailboatImage.height * sailboat.size > boatCanvas.height) {
            sailboat.y = boatCanvas.height - sailboatImage.height * sailboat.size;
            sailboat.speedY = -Math.abs(sailboat.speedY); // Move up
          }
        }
      });
    }
    
    function drawSailboats() {
      boatCtx.clearRect(0, 0, boatCanvas.width, boatCanvas.height);
      
      if (sailboatImage.complete) {
        // Sort sailboats by Y position (lower Y drawn first, higher Y drawn last = in front)
        const sortedSailboats = [...sailboats].sort((a, b) => a.y - b.y);
        
        sortedSailboats.forEach(sailboat => {
          boatCtx.save();
          // Flip image if moving left
          if (sailboat.speedX < 0) {
            boatCtx.scale(-1, 1);
            boatCtx.drawImage(
              sailboatImage,
              -(sailboat.x + sailboatImage.width * sailboat.size),
              sailboat.y,
              sailboatImage.width * sailboat.size,
              sailboatImage.height * sailboat.size
            );
          } else {
            boatCtx.drawImage(
              sailboatImage,
              sailboat.x,
              sailboat.y,
              sailboatImage.width * sailboat.size,
              sailboatImage.height * sailboat.size
            );
          }
          boatCtx.restore();
        });
      }
    }

    function spawnNewCloud() {
      const size = 0.3 + Math.random() * 0.5;
      const x = cloudCanvas.width + 50; // Start off-screen to the right
      clouds.push({
        x: x,
        y: Math.random() * (cloudCanvas.height * 0.7),
        size: size,
      });
    }
  </script>
</body>
</html> 