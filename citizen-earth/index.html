<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, orientation=portrait">
  <title>Citizen Earth</title>
  <style>
    html, body {
      height: 100%;
    }
    body {
      background: #4DD0E1;
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: pan-y;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    #water-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      pointer-events: none;
      display: block;
    }
    #cloud-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 4;
      pointer-events: none;
      display: block;
    }
    #boat-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 3;
      pointer-events: none;
      display: block;
    }
    h1 {
      text-align: center;
      margin-top: 43px;
      font-size: 2.5rem;
      color: #222;
      z-index: 5;
      position: relative;
      pointer-events: none;
    }
    #sunk-ships-counter {
      position: fixed;
      top: 10px;
      right: 20px;
      background: rgba(44, 62, 80, 0.9);
      color: #fff;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 1.2rem;
      z-index: 9999;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      pointer-events: none;
    }
    .island-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      max-width: 1200px;
      margin-top: 40px;
      margin-bottom: 0px;
      margin-left: auto;
      margin-right: auto;

      direction: ltr;
    }
    .island {
      display: flex;
      flex-direction: column;
      align-items: center;
      border-radius: 18px;
      padding: 16px 8px 8px 8px;
      transition: transform 0.2s;
      cursor: pointer;
    }

    .island img {
      width: 120px;
      height: auto;
      margin-bottom: 12px;
      border-radius: 12px;
    }
    .city-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2a4d69;
      text-align: center;
      position: relative;
      z-index: 5;
    }
    @media (max-width: 900px) {
      .island-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 600px) {
      html {
        scroll-snap-type: y mandatory;
        scroll-behavior: smooth;
      }
      body {
        scroll-snap-type: y mandatory;
      }
      .island-grid {
        grid-template-columns: 1fr !important;
        justify-items: center;
        gap: 10vh;
        padding: 0 20px;
      }
      .island {
        grid-area: auto !important;
        scroll-snap-align: center;
        scroll-snap-stop: always;
        
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
    }
    .island-tooltip {
      background: rgba(44, 62, 80, 0.97);
      color: #fff;
      padding: 10px 16px;
      border-radius: 5px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.18);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
      z-index: 10;
      font-size: 1rem;
      margin-top: 1.5em;
    }
    .island {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .island-tooltip a {
      color: #ffd700;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <canvas id="water-canvas"></canvas>
  <canvas id="cloud-canvas"></canvas>
  <canvas id="boat-canvas"></canvas>
  <h1>Citizen Earth</h1>
  <div id="sunk-ships-counter">Ships Sunk: 0</div>
  <div class="island-grid" style="position:relative; z-index:2;">
    <!-- Islands will be inserted here by JS -->
  </div>
  <svg id="island-lines" style="position:absolute; top:0; left:0; pointer-events:none; z-index:1;"></svg>
  <footer style="position: fixed; bottom: 2px; width: 100%; text-align: center; opacity: 0.2; font-size: 0.8rem; color: #222;">
    Version 1.0.6
  </footer>
  <script>
    // SpaceTracker class definition
    class SpaceTracker {
      constructor(pageHeight) {
        // Initialize with a single range covering the entire page height
        this.ranges = [{
          start: 0,
          end: pageHeight
        }];
      }

      // Add a new occupied space to the tracker
      addOccupiedSpace(start, height) {
        const end = start + height;
        const newRanges = [];
        
        for (const range of this.ranges) {
          // If the occupied space is completely outside this range, keep the range as is
          if (end <= range.start || start >= range.end) {
            newRanges.push({...range});
            continue;
          }
          
          // If the occupied space splits this range, create two new ranges
          if (start > range.start && end < range.end) {
            newRanges.push({
              start: range.start,
              end: start
            });
            newRanges.push({
              start: end,
              end: range.end
            });
          }
          // If the occupied space overlaps the start of the range
          else if (start <= range.start && end < range.end) {
            newRanges.push({
              start: end,
              end: range.end
            });
          }
          // If the occupied space overlaps the end of the range
          else if (start > range.start && end >= range.end) {
            newRanges.push({
              start: range.start,
              end: start
            });
          }
          // If the occupied space completely covers the range, skip it
        }
        
        // Sort ranges by start position and merge adjacent ranges
        this.ranges = newRanges;
      }

      // Get all available spaces that are at least minHeight tall
      getAvailableSpaces(minHeight) {
        return this.ranges.filter(range => (range.end - range.start) >= minHeight);
      }

      // Get a random available space that is at least minHeight tall
      getRandomAvailableSpace(minHeight) {
        const availableSpaces = this.getAvailableSpaces(minHeight);
        if (availableSpaces.length === 0) return null;
        
        const randomSpace = availableSpaces[Math.floor(Math.random() * availableSpaces.length)];
        
        return {
          start: randomSpace.start,
          height: minHeight
        };
      }

      // Clear all ranges and reset to full page height
      reset(pageHeight) {
        this.ranges = [{
          start: 0,
          end: pageHeight
        }];
      }

      // Get the total available space
      getTotalAvailableSpace() {
        return this.ranges.reduce((total, range) => total + (range.end - range.start), 0);
      }
    }


    const debugMode = false;
    // Initialize SpaceTracker with page height
    const spaceTracker = new SpaceTracker(document.documentElement.scrollHeight);

    // Modify the renderIslands function to use SpaceTracker
    function renderIslands() {
      grid.innerHTML = '';
      const cols = getColumnCount();
      const rows = Math.ceil(cities.length / cols);
      const positions = [];
      
      cities.forEach((cityObj, i) => {
        const row = Math.floor(i / cols);
        let col = i % cols;
        if (row % 2 === 1) col = cols - 1 - col;
        const div = document.createElement('div');
        div.className = 'island';
        div.style.gridRow = (row + 1).toString();
        div.style.gridColumn = (col + 1).toString();
        div.innerHTML = `
          <img src="${cityObj.islandImg}" alt="${cityObj.name}" style="width: ${cityObj.size ? cityObj.size + 'px' : '120px'}; height: auto;">
          <div class="city-name">${cityObj.name}</div>
          <div class="island-tooltip">
            <div><strong>${cityObj.duration}</strong></div>
            <div>${cityObj.dates}</div>
            ${cityObj.link ? `<div><a href="${cityObj.link}" target="_blank">${cityObj.linkText}</a></div>` : ''}
          </div>
        `;
        positions.push({row, col, div});
        
        // Add island to SpaceTracker after it's rendered
        const img = div.querySelector('img');
        const rect = img.getBoundingClientRect();
        
        // Tooltip show/hide
        div.addEventListener('mouseenter', () => {
          div.querySelector('.island-tooltip').style.opacity = 1;
        });
        div.addEventListener('mouseleave', () => {
          div.querySelector('.island-tooltip').style.opacity = 0;
        });
        grid.appendChild(div);
      });
      
      setTimeout(updateIslandBounds, 100);
      setTimeout(() => {
        storeIslandBounds();
        drawLines(positions, cols, rows);
        setupMobileTooltips();
        if (!canvasesInitialized) {
          canvasesInitialized = true;
          updateAllCanvasSizes();
          initializeClouds();
          initializeSailboats();
        }
      }, 300);

      document.addEventListener('DOMContentLoaded', () => {
        storeIslandBounds();
        drawLines(positions, cols, rows);
      });
    }

    // Lock orientation to portrait on mobile devices
    if (window.innerWidth <= 600 && screen.orientation && screen.orientation.lock) {
      screen.orientation.lock('portrait').catch(() => {
        // Orientation lock not supported or failed
        console.log('Orientation lock not supported');
      });
    }

    // Water effect
    const waterCanvas = document.getElementById('water-canvas');
    const ctx = waterCanvas.getContext('2d');
    
    // Cloud system
    const cloudImage = new Image();
    cloudImage.src = './images/cloud.png';
    let clouds = [];
    const cloudSpeed = 0.1; // pixels per frame
    let islandBounds = []; // Store top and bottom Y values of each island
    const cloudSpawnProbability = 0.0004;
    
    // Sailboat system
    const sailboatImage = new Image();
    sailboatImage.src = './images/sailboat.png';
    let sailboats = [];
    let sailboatSpawnProbability = 0.003;
    const boatCollisionPercentage = 0.15;

    // Replace the single lastFrameTime with separate timing variables
    let lastCloudFrameTime = 0;
    let lastBoatFrameTime = 0;

    // Add boss ship properties near the top with other global variables
    let bossShip = null;
    const bossShipImage = new Image();
    bossShipImage.src = './images/trimast.png';
    const bossShipDamagedImage = new Image();
    bossShipDamagedImage.src = './images/trimast_damaged.png';
    const bossShipFlotsamImage = new Image();
    bossShipFlotsamImage.src = './images/trimast_flotsam.png';

    // Add damage icon properties near the top with other global variables
    const damageIconImage = new Image();
    damageIconImage.src = './images/damage_icon.png';
    const damageIconScale = 0.1;
    let damageFlash = null;

    function checkSailboatOverlap(sailboatX, sailboatY, sailboatWidth, sailboatHeight) {
      const sailboatBottom = sailboatY + sailboatHeight;
      const sailboatTop = sailboatY + sailboatHeight * (1 - boatCollisionPercentage);
      const sailboatRight = sailboatX + sailboatWidth;

      if (debugMode) {
        // Draw collision box
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.rect(
          sailboatX,
          sailboatTop,
          sailboatWidth,
          sailboatBottom - sailboatTop
        );
        ctx.stroke();
      }
      
      // Check if sailboat overlaps with any island
      for (let island of islandBounds) {
        if ((sailboatX == -1 || (sailboatX < island.right && sailboatRight > island.left)) &&
            sailboatTop < island.bottom && sailboatBottom > island.top) {
          return true; // Overlap detected
        }
      }
      return false; // No overlap
    }
    
    function getValidSailboatPosition(sailboatSize) {
      const maxAttempts = 50;
      let attempts = 0;
      
      const initialBoatWidth = sailboatImage.width * sailboatSize;
      const initialBoatHeight = sailboatImage.height * sailboatSize;
      
      while (attempts < maxAttempts) {
        const randomX = Math.random() * boatCanvas.width;
        const randomY = Math.random() * boatCanvas.height;
        
        if (!checkSailboatOverlap(randomX, randomY, initialBoatWidth, initialBoatHeight)) {
          return { x: randomX, y: randomY };
        }
        attempts++;
      }
      
      // If we couldn't find a valid position, try some fallback positions
      const fallbackPositions = [
        { x: 50, y: 50 },
        { x: boatCanvas.width - 50, y: 50 },
        { x: 50, y: boatCanvas.height - 50 },
        { x: boatCanvas.width - 50, y: boatCanvas.height - 50 }
      ];
      
      // Try each fallback position
      for (let pos of fallbackPositions) {
        if (!checkSailboatOverlap(pos.x, pos.y, initialBoatWidth, initialBoatHeight)) {
          return pos;
        }
      }
      
      // If all else fails, return a default position
      return { x: 50, y: 50 };
    }
    
    function initializeSailboats() {
      sailboats = [];
      
      // Start with 2 sailboats on the page
      for (let i = 0; i < 2; i++) {
        const size = 0.4;
        const direction = Math.random() > 0.5 ? 1 : -1;
        const validPosition = getValidSailboatPosition(size);
        
        sailboats.push(new Boat(
          validPosition.x,
          validPosition.y,
          size,
          (0.1 + Math.random() * 0.1) * direction,
          (Math.random() - 0.5) * 0.05,
          sailboatImage,
          0,
          .004,
          false
        ));
      }
    }

    // Cloud canvas setup
    const cloudCanvas = document.getElementById('cloud-canvas');
    const cloudCtx = cloudCanvas.getContext('2d');
    
    function resizeCloudCanvas() {      
      cloudCanvas.width = Math.max(document.documentElement.scrollWidth, window.innerWidth);
      cloudCanvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight, document.body.offsetHeight);
    }
    
    // Boat canvas setup
    const boatCanvas = document.getElementById('boat-canvas');
    const boatCtx = boatCanvas.getContext('2d');
    
    function resizeBoatCanvas() {      
      boatCanvas.width = Math.max(document.documentElement.scrollWidth, window.innerWidth);
      boatCanvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight, document.body.offsetHeight);
    }
    
    function updateIslandBounds() {
      islandBounds = [];
      const islands = document.querySelectorAll('.island img');
      islands.forEach(img => {
        const rect = img.getBoundingClientRect();
        islandBounds.push({
          top: rect.top + window.scrollY,
          bottom: rect.bottom + window.scrollY,
          left: rect.left + window.scrollX,
          right: rect.right + window.scrollX
        });
      });
      
      // Draw debug rectangles
      if (debugMode) {
        drawIslandBounds();
      }
    }

    function getDebugCanvas() {
      let debugCanvas = document.getElementById('debug-canvas');
      if (!debugCanvas) {
        debugCanvas = document.createElement('canvas');
        debugCanvas.id = 'debug-canvas';
        debugCanvas.style.position = 'absolute';
        debugCanvas.style.top = '0';
        debugCanvas.style.left = '0';
        debugCanvas.style.pointerEvents = 'none';
        debugCanvas.style.zIndex = '9999';
        document.body.appendChild(debugCanvas);
      }
      return debugCanvas;
    }
    
    function drawIslandBounds() {
      // Create or get debug canvas
      let debugCanvas = getDebugCanvas();
      
      const ctx = debugCanvas.getContext('2d');
      debugCanvas.width = window.innerWidth;
      debugCanvas.height = document.documentElement.scrollHeight;
      
      // Clear previous drawings
      ctx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
      
      // Draw red rectangles for each island
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.lineWidth = 2;
      
      islandBounds.forEach(bounds => {
        ctx.beginPath();
        ctx.rect(
          bounds.left,
          bounds.top,
          bounds.right - bounds.left,
          bounds.bottom - bounds.top
        );
        ctx.stroke();
      });
    }

    // Function to draw debug lines for available spaces
    function drawSpaceTrackerLines() {
      let debugCanvas = getDebugCanvas();

      const ctx = debugCanvas.getContext('2d');
      debugCanvas.width = window.innerWidth;
      debugCanvas.height = document.documentElement.scrollHeight;
      
      // Draw red lines for each available space
      const availableSpaces = spaceTracker.getAvailableSpaces(1);
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.lineWidth = 2;
      
      availableSpaces.forEach(space => {
        ctx.beginPath();
        ctx.moveTo(1, space.start);
        ctx.lineTo(1, space.end);
        ctx.stroke();
      });
    }
    
    function initializeClouds() {
      clouds = [];
      const cloudCount = 5;
      for (let i = 0; i < cloudCount; i++) {
        const size = 0.3 + Math.random() * 0.5;
        const x = Math.random() * cloudCanvas.width;
        clouds.push({
          x: x,
          y: Math.random() * cloudCanvas.height, // Use full canvas height
          size: size,
        });
      }
    }
    
    // Update the cloud animation function
    function animateClouds(currentTime) {
      if (!lastCloudFrameTime) lastCloudFrameTime = currentTime;
      const deltaTime = currentTime - lastCloudFrameTime;
      lastCloudFrameTime = currentTime;
      
      updateClouds(deltaTime);
      drawClouds();
      requestAnimationFrame(animateClouds);
    }

    // Update the boat animation function
    function animateBoats(currentTime) {
      if (!lastBoatFrameTime) lastBoatFrameTime = currentTime;
      const deltaTime = currentTime - lastBoatFrameTime;
      lastBoatFrameTime = currentTime;
      
      updateSailboats(deltaTime);
      drawSailboats(deltaTime);
      requestAnimationFrame(animateBoats);
    }

    // Update the cloud movement to use deltaTime
    function updateClouds(deltaTime) {
      // Random chance to spawn a new cloud each frame
      if (Math.random() < cloudSpawnProbability * (deltaTime / 16.67)) { // Normalize to 60fps
        spawnNewCloud();
      }
      
      // Update existing clouds and remove those that have exited
      for (let i = clouds.length - 1; i >= 0; i--) {
        const cloud = clouds[i];
        cloud.x -= cloudSpeed * (deltaTime / 16.67); // Normalize to 60fps
        
        // Remove cloud if it has completely exited the left side
        if (cloud.x + cloudImage.width * cloud.size < 0) {
          clouds.splice(i, 1);
        }
      }
    }

    function drawClouds() {
      cloudCtx.clearRect(0, 0, cloudCanvas.width, cloudCanvas.height);
      
      if (cloudImage.complete) {
        clouds.forEach(cloud => {
          cloudCtx.save();
          cloudCtx.globalAlpha = 1.0;
          cloudCtx.drawImage(
            cloudImage,
            cloud.x,
            cloud.y,
            cloudImage.width * cloud.size,
            cloudImage.height * cloud.size
          );
          cloudCtx.restore();
        });
      }
    }
    
    function resizeWaterCanvas() {      
      waterCanvas.width = Math.max(document.documentElement.scrollWidth, window.innerWidth);
      waterCanvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight, document.body.offsetHeight);
    }
    
    function updateAllCanvasSizes() {
      resizeWaterCanvas();
      resizeCloudCanvas(); 
      resizeBoatCanvas();
    }
    
    function drawWater(time) {
      ctx.clearRect(0, 0, waterCanvas.width, waterCanvas.height);
      // Base water color - teal/turquoise
      ctx.fillStyle = '#4DD0E1';
      ctx.fillRect(0, 0, waterCanvas.width, waterCanvas.height);
      
      // Draw subtle crescent wave lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineCap = 'round';
      
      for (let i = 0; i < 15; i++) {
        ctx.beginPath();
        ctx.lineWidth = 2;
        
        // Create crescent shapes at different positions with independent movement
        const baseX = (i / 15) * waterCanvas.width + Math.sin(i * 1.7) * (waterCanvas.width * 0.2);
        
        // Calculate Y position with downward movement
        const waveSpeed = 0.005; // Speed of downward movement
        const waveHeight = waterCanvas.height + 100; // Extra height for smooth transition
        const baseY = ((time * waveSpeed) + (i * 80)) % waveHeight;
        
        const xCenter = baseX;
        const crescentWidth = 20 + Math.sin(i * 0.3) * 2;
        const crescentHeight = 3 + Math.sin(i * 0.7) * .7;
        
        // Draw crescent curve with shadow for dimension
        const alpha = 0.2 + Math.sin(i * 0.5 + time * 0.001) * 0.1;
        
        // First draw the shadow (darker, offset down)
        ctx.beginPath();
        for (let t = -Math.PI * 0.4; t <= Math.PI * 0.4; t += 0.05) {
          const x = xCenter + Math.sin(t) * crescentWidth;
          const y = baseY + Math.cos(t * 2) * crescentHeight + 2; // Offset shadow down by 2px
          
          if (t === -Math.PI * 0.4) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.strokeStyle = `rgba(0, 50, 80, ${alpha * 0.6})`; // Dark blue-gray shadow
        ctx.stroke();
        
        // Then draw the main line (white, on top)
        ctx.beginPath();
        for (let t = -Math.PI * 0.4; t <= Math.PI * 0.4; t += 0.05) {
          const x = xCenter + Math.sin(t) * crescentWidth;
          const y = baseY + Math.cos(t * 2) * crescentHeight;
          
          if (t === -Math.PI * 0.4) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.lineWidth = 4;
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.stroke();
      }
      
      requestAnimationFrame(drawWater);
    }
    requestAnimationFrame(drawWater);
    
    // Start cloud animation
    requestAnimationFrame(animateClouds);
    
    // Start boat animation
    requestAnimationFrame(animateBoats);

    // Placeholder cities with metadata
    const cities = [
      { 
        name: 'Miami',
        dates: 'Jan - Apr',
        duration: '3 months',
        islandImg: './images/miami.png',
        link: 'https://mirror.xyz/citizenearth.eth/mdQHEpgT3U0ZLge1NOm4xoMebfHwoaREPSYK3GIOdSc',
        linkText: 'Tied down'
      },
      { 
        name: 'New York', 
        dates: 'Apr', 
        duration: '1 month',
        islandImg: './images/NY.png',
        size: 200
      },
      { 
        name: 'Madrid', 
        dates: 'Apr - May', 
        duration: '1 week',
        islandImg: './images/madrid.png' ,
        size: 150
      },
      { 
        name: 'Granada', 
        dates: 'May', 
        duration: '2 weeks',
        islandImg: './images/granada.png' ,
        size: 200
      },
      { 
        name: 'Hyeres', 
        dates: 'May - Jun', 
        duration: '1 month',
        islandImg: './images/hyeres.png',
        size: 160
      },
      { 
        name: 'Antibes', 
        dates: 'Jun', 
        duration: '3 weeks',
        islandImg: './images/antibes.png',
        size: 160
      },
      { 
        name: 'Cannes', 
        dates: 'Jun-July', 
        duration: '1 week',
        islandImg: './images/cannes.png',
        size: 160
      },
      { 
        name: '???', 
        dates: 'July-Aug', 
        duration: '???',
        islandImg: './images/mystery.png',
      },
      { 
        name: 'Dakhla', 
        dates: 'Aug', 
        duration: '2 weeks',
        islandImg: './images/dakhla.png',
        size: 160
      },
      { 
        name: '???', 
        dates: 'Sept-Oct', 
        duration: '???',
        islandImg: './images/mystery.png',
      },
      { 
        name: 'Buenos Aires', 
        dates: 'Nov', 
        duration: '???',
        islandImg: './images/buenos_aires.png',
        size: 160
      },
      { 
        name: 'Orange County', 
        dates: 'Dec', 
        duration: '1 month',
        islandImg: './images/orange_county.png',
        size: 140
      },
    ];

    // Responsive grid: let CSS handle columns, JS figures out columns dynamically
    const grid = document.querySelector('.island-grid');
    const svg = document.getElementById('island-lines');
    function getColumnCount() {
      const style = window.getComputedStyle(grid);
      const templateColumns = style.getPropertyValue('grid-template-columns');
      return templateColumns.split(' ').length;
    }

    let canvasesInitialized = false;
    function drawLines(positions, cols, rows) {
      svg.innerHTML = '';
      svg.setAttribute('width', document.body.scrollWidth);
      svg.setAttribute('height', document.body.scrollHeight);
      // Get center positions of each island image
      const centers = positions.map(({div}) => {
        const img = div.querySelector('img');
        const rect = img.getBoundingClientRect();
        return {
          x: rect.left + rect.width/2 + window.scrollX,
          y: rect.top + rect.height/2 + window.scrollY
        };
      });
      for (let i = 0; i < centers.length - 1; i++) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', centers[i].x);
        line.setAttribute('y1', centers[i].y);
        line.setAttribute('x2', centers[i+1].x);
        line.setAttribute('y2', centers[i+1].y);
        line.setAttribute('stroke', 'rgba(255, 255, 255, 0.5)');
        line.setAttribute('stroke-width', '4');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('stroke-dasharray', '8,8');
        svg.appendChild(line);
      }
    }

    function storeIslandBounds() {
      // Reset SpaceTracker with current page height
      spaceTracker.reset(document.documentElement.scrollHeight);
      const islands = document.querySelectorAll('.island');
      islands.forEach(island => {
        const img = island.querySelector('img');
        const rect = img.getBoundingClientRect();
        spaceTracker.addOccupiedSpace(rect.top + window.scrollY, rect.height);
      });
      if (debugMode) {
        drawSpaceTrackerLines();
      }
    }
    // Set grid-template-columns to be responsive
    grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(180px, 1fr))';
    window.addEventListener('resize', renderIslands);
    renderIslands();

    // Mobile tooltip auto-display functionality
    function setupMobileTooltips() {
      // Check if device is mobile
      const isMobile = window.innerWidth <= 600;
      if (!isMobile) return;

      const islands = document.querySelectorAll('.island');
      const firstIsland = islands[0];
      const lastIsland = islands[islands.length - 1];

      // Create intersection observer for center screen detection
      const observerOptions = {
        root: null,
        rootMargin: '-30% 0px -30% 0px', // Only trigger when in center 40% of screen
        threshold: 0.5
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const tooltip = entry.target.querySelector('.island-tooltip');
          if (entry.isIntersecting) {
            // Island is in center area - show tooltip
            tooltip.style.opacity = '1';
            tooltip.style.transform = 'translateY(-10px)';
          } else {
            // Island is outside center area - hide tooltip
            tooltip.style.opacity = '0';
            tooltip.style.transform = 'translateY(0)';
          }
        });
      }, observerOptions);

      // Observe all islands
      islands.forEach(island => {
        observer.observe(island);
      });

      // Handle scroll for first/last island edge cases
      function handleScroll() {
        if (debugMode) {
          drawSpaceTrackerLines();
        }
        const scrollY = window.scrollY;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        
        // Show first island tooltip when at top of page
        if (scrollY <= 50) { // Within 50px of top
          const firstTooltip = firstIsland.querySelector('.island-tooltip');
          firstTooltip.style.opacity = '1';
          firstTooltip.style.transform = 'translateY(-10px)';
        }
        
        // Show last island tooltip when at bottom of page
        if (scrollY + windowHeight >= documentHeight - 50) { // Within 50px of bottom
          const lastTooltip = lastIsland.querySelector('.island-tooltip');
          lastTooltip.style.opacity = '1';
          lastTooltip.style.transform = 'translateY(-10px)';
        }
      }

      // Add scroll listener
      window.addEventListener('scroll', handleScroll);
      
      // Initial check
      handleScroll();
    }

    let totalSunkShips = 0;
    const sunkShipsCounter = document.getElementById('sunk-ships-counter');

    function updateSunkShipsCounter() {
      if (totalSunkShips > 0) {
        sunkShipsCounter.style.display = 'block';
        sunkShipsCounter.textContent = `Ships Sunk: ${totalSunkShips}`;
        
        if (totalSunkShips > 10) {
          sailboatSpawnProbability = 0.01;
        }
        
        // Spawn boss ship at 50 sunk ships
        const bossShipSpawnThreshold = debugMode ? 1 : window.innerWidth <= 600 ? 30 : 50;
        if (totalSunkShips === bossShipSpawnThreshold && !bossShip) {
          spawnBossShip();
        }
      } else {
        sunkShipsCounter.style.display = 'none';
      }
    }

    // Base Boat class
    class Boat {
      constructor(x, y, size, speedX, speedY, image, sinkProgress, sinkSpeed, hasFlotsam) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.speedX = speedX;
        this.speedY = speedY;
        this.originalSpeedX = speedX;
        this.image = image;
        this.stopped = false;
        this.stopTimer = 0;
        this.bobbingPhase = Math.PI * 2;
        this.sinking = false;
        this.rotation = 0;
        this.sinkProgress = sinkProgress;
        this.sinkSpeed = sinkSpeed;
        this.isFlotsam = false;
        this.flotsamTimer = 0;
        this.hasFlotsam = hasFlotsam;
        this.sinkStartY = 0; // Add this to store the Y position when sinking starts
        this.opacity = 1; // Add opacity property
        this.hasEnteredScreen = false; // Add this to track if the ship has entered the screen
      }

      update(deltaTime) {
        if (this.isFlotsam) {
          if (this.hasFlotsam) {
            this.sinking = false;
            this.sinkProgress = 0;
            this.y = this.sinkStartY - 50; // Restore the Y position when becoming flotsam
            
            // Add bobbing animation for flotsam
            this.y += Math.sin(this.flotsamTimer * 0.005 + this.bobbingPhase) * .08 * (deltaTime / 16.67);

            // Add flotsam bounds when ship becomes flotsam
            const boatWidth = this.image.width * this.size;
            const boatHeight = this.image.height * this.size;
            this.flotsamBounds = {
              left: this.x,
              right: this.x + boatWidth,
              top: this.y,
              bottom: this.y + boatHeight
            };
            islandBounds.push(this.flotsamBounds);
          }
          else {
            return false;
          }
          this.flotsamTimer += deltaTime;
        } else if (this.sinking) {
          if (this.sinkStartY === 0) { // Store Y position when sinking starts
            this.sinkStartY = this.y;
          }
          this.speedX = this.speedX * Math.pow(0.99, deltaTime / 16.67);
          this.x += this.speedX * (deltaTime / 16.67);
          const sinkSpeed = this.sinkSpeed * (deltaTime / 16.67);
          this.sinkProgress += sinkSpeed;
          this.y += sinkSpeed * this.size * this.image.height * 0.8;
          
          if (this.sinkProgress >= 1) {
            this.isFlotsam = true;
            this.flotsamTimer = 0;
          }
        } else {
          if (this.stopped) {
            this.stopTimer += deltaTime;
            this.y += Math.sin(this.stopTimer * 0.005 + this.bobbingPhase) * .08 * (deltaTime / 16.67);
            
            if (this.stopTimer >= 5000) {
              this.stopped = false;
              this.stopTimer = 0;
              this.speedX = -this.originalSpeedX;
              this.speedY = -this.speedY;
            }
          } else {
            const prevX = this.x;
            const prevY = this.y;
            
            this.x += this.speedX * (deltaTime / 16.67);
            this.y += this.speedY * (deltaTime / 16.67);
            
            // Check for island collision using actual dimensions
            const currentBoatWidth = this.image.width * this.size;
            const currentBoatHeight = this.image.height * this.size;
            if (checkSailboatOverlap(this.x, this.y, currentBoatWidth, currentBoatHeight)) {
              this.x = prevX;
              this.y = prevY;
              this.stopped = true;
              this.stopTimer = 0;
            }
            
            // Handle vertical screen edges
            if (this.y < 0) {
              this.y = 0;
              this.speedY = Math.abs(this.speedY);
            }
            if (this.y + this.image.height * this.size > boatCanvas.height) {
              this.y = boatCanvas.height - this.image.height * this.size;
              this.speedY = -Math.abs(this.speedY);
            }

            // Handle horizontal screen edges - special case for boss ship
            const boatWidth = this.image.width * this.size;
            if (this instanceof BossShip) {
              // Only respawn if the ship has entered the screen and then gone off-screen
              if (this.hasEnteredScreen && (this.x + boatWidth < 0 || this.x > boatCanvas.width)) {
                return 'respawn';
              }
              
              // Mark that the ship has entered the screen
              if (this.x >= 0 && this.x <= boatCanvas.width) {
                this.hasEnteredScreen = true;
              }
            } else {
              // Regular boats can leave the screen
              if (this.x + boatWidth < 0 || this.x > boatCanvas.width) {
                return false; // Remove the boat
              }
            }
          }
        }
        return true; // Keep the boat
      }

      draw(ctx) {
        ctx.save();
        
        const centerX = this.x + (this.image.width * this.size) / 2;
        const centerY = this.y + (this.image.height * this.size) / 2;
        
        ctx.translate(centerX, centerY);
        
        if (this.speedX > 0) {
          ctx.scale(-1, 1);
        }
        
        if (this.sinkProgress > 0) {
          const clipHeight = this.image.height * this.size * (1 - this.sinkProgress);
          
          ctx.beginPath();
          const width = this.image.width * this.size;
          const segments = 20;
          const segmentWidth = width / segments;
          
          ctx.moveTo(-width/2, -this.image.height * this.size / 2);
          
          // Add time-based animation to the wave
          const time = Date.now() * 0.001; // Convert to seconds for smoother animation
          
          // Create multiple overlapping waves with different frequencies and phases
          const waveAmplitude = this.size * 2; // Scale amplitude based on boat size
          const waveDirection = this.speedX > 0 ? -1 : 1; // Reverse direction based on ship movement
          
          for (let i = 0; i <= segments; i++) {
            const x = -width/2 + (i * segmentWidth);
            // Adjust wave phases based on direction
            const phase1 = i * 1.2 - (time * 2);
            const phase2 = i * 0.8 - (time * 1.5);
            const phase3 = i * 1.5 - (time * 2.5);
            
            const wave1 = Math.sin(phase1) * waveAmplitude; // Primary wave
            const wave2 = Math.sin(phase2) * (waveAmplitude * 0.7); // Secondary wave
            const wave3 = Math.sin(phase3) * (waveAmplitude * 0.5); // Tertiary wave
            
            const combinedWave = waveDirection * (wave1 + wave2 + wave3);
            const y = -this.image.height * this.size / 2 + clipHeight + combinedWave;
            ctx.lineTo(x, y);
          }
          
          ctx.lineTo(width/2, -this.image.height * this.size / 2);
          ctx.closePath();
          ctx.clip();
        }

        // Handle flotsam fade-in
        if (this.isFlotsam) {
          // Calculate opacity based on flotsamTimer
          const fadeDuration = 1000; // 1 second fade-in
          this.opacity = Math.min(1, this.flotsamTimer / fadeDuration);
          ctx.globalAlpha = this.opacity;
        }
        
        ctx.drawImage(
          this.image,
          -(this.image.width * this.size) / 2,
          -(this.image.height * this.size) / 2,
          this.image.width * this.size,
          this.image.height * this.size
        );
        
        ctx.restore();
      }

      isPointInside(x, y) {
        const boatWidth = this.image.width * this.size;
        const boatHeight = this.image.height * this.size;
        
        const adjustedX = this.speedX > 0 ? 
          this.x + boatWidth - (x - this.x) : 
          x;
        
        return adjustedX >= this.x && 
               adjustedX <= this.x + boatWidth &&
               y >= this.y && 
               y <= this.y + boatHeight;
      }
    }

    // BossShip class
    class BossShip extends Boat {
      constructor(x, y, size, speedX, image, damagedImage, flotsamImage) {
        super(x, y, size, speedX, 0, image, 0.08, .002, true);
        this.damagedImage = damagedImage;
        this.flotsamImage = flotsamImage;
        this.damage = 0;
      }

      draw(ctx) {
        // Override draw to use different images based on state
        const currentImage = this.isFlotsam ? 
          this.flotsamImage : 
          (this.damage >= 20 ? this.damagedImage : this.image);
        
        this.image = currentImage; // Temporarily set image for base class draw
        super.draw(ctx);
      }
    }

    function createBossShip(x, y, direction, size) {
      return new BossShip(
        x,
        y,
        size,
        (0.15 + Math.random() * 0.05) * direction,
        bossShipImage,
        bossShipDamagedImage,
        bossShipFlotsamImage
      );
    }

    function spawnNewSailboat() {
      if (!sailboatImage.complete) return;
      
      const size = 0.4;
      const direction = Math.random() > 0.5 ? 1 : -1;
      const boatWidth = sailboatImage.width * size;
      
      const x = direction === 1 ? -boatWidth : boatCanvas.width;
      const validPosition = getValidSailboatPosition(size);
      
      sailboats.push(new Boat(
        x,
        validPosition.y,
        size,
        (0.1 + Math.random() * 0.1) * direction,
        (Math.random() - 0.5) * 0.05,
        sailboatImage,
        0,
        .004,
        false
      ));
    }

    function findValidBossShipPosition(size, direction) {
      const boatWidth = bossShipImage.width * size;
      
      // Start just slightly off-screen
      const x = direction === 1 ? bossShipImage.width * -1 : boatCanvas.width + 1;
      
      // Use SpaceTracker to find a valid Y position
      const boatHeight = bossShipImage.height * size;
      const overlapHeight = boatHeight * boatCollisionPercentage; // Only check bottom x%
      const availableSpace = spaceTracker.getRandomAvailableSpace(overlapHeight);
      
      if (!availableSpace) {
        // Fallback to middle of screen if no valid space found
        return { x, y: boatCanvas.height * 0.5 };
      }
      
      // Position the ship so its bottom x% is into the available space
      return { x, y: availableSpace.start + (boatHeight - overlapHeight) + 20 };
    }

    function spawnBossShip() {
      if (!bossShipImage.complete) return;
      
      const size = window.innerWidth <= 600 ? 0.6 : 0.8;
      const direction = Math.random() > 0.5 ? 1 : -1;
      const position = findValidBossShipPosition(size, direction);
      
      bossShip = createBossShip(position.x, position.y, direction, size);
    }

    function updateSailboats(deltaTime) {
      // Update boss ship
      if (bossShip) {
        const result = bossShip.update(deltaTime);

        if (result === 'respawn') {
          // Respawn boss ship with same state
          const currentState = {
            damage: bossShip.damage,
            sinking: bossShip.sinking,
            sinkProgress: bossShip.sinkProgress,
            isFlotsam: bossShip.isFlotsam,
            flotsamTimer: bossShip.flotsamTimer
          };
          
          // Spawn new boss ship
          const size = window.innerWidth <= 600 ? 0.6 : 0.8;
          const direction = Math.random() > 0.5 ? 1 : -1;
          // sets the position based on the direction of the boss ship
          const position = findValidBossShipPosition(size, direction);
          
          bossShip = createBossShip(position.x, position.y, direction, size);
          
          // Restore previous state
          bossShip.damage = currentState.damage;
          bossShip.sinking = currentState.sinking;
          bossShip.sinkProgress = currentState.sinkProgress;
          bossShip.isFlotsam = currentState.isFlotsam;
          bossShip.flotsamTimer = currentState.flotsamTimer;
        } else if (result === false) {
          bossShip = null;
        }
      }
      
      // Update regular boats
      for (let i = sailboats.length - 1; i >= 0; i--) {
        if (!sailboats[i].update(deltaTime)) {
          if (sailboats[i].sinkProgress >= 1) {
            totalSunkShips++;
            updateSunkShipsCounter();
          }
          sailboats.splice(i, 1);
        }
      }
      
      // Random chance to spawn new boat
      if (Math.random() < sailboatSpawnProbability * (deltaTime / 16.67)) {
        spawnNewSailboat();
      }
    }

    // Update the drawSailboats function to include damage flash
    function drawSailboats(deltaTime) {
      boatCtx.clearRect(0, 0, boatCanvas.width, boatCanvas.height);
      
      if (sailboatImage.complete) {
        // Create array of all boats including boss ship
        const allBoats = [...sailboats];
        if (bossShip) {
          allBoats.push(bossShip);
        }
        
        // Sort boats by their bottom Y position (y + height)
        const sortedBoats = allBoats.sort((a, b) => {
          const aBottom = a.y + (a.image.height * a.size * (1-a.sinkProgress));
          const bBottom = b.y + (b.image.height * b.size * (1-b.sinkProgress));
          return aBottom - bBottom;
        });

        sortedBoats.forEach(boat => {
          boat.draw(boatCtx);
        });

        // Draw damage flash if active
        if (damageFlash) {
          damageFlash.opacity -= 0.1 * (deltaTime / 16.67);
          if (damageFlash.opacity <= 0) {
            damageFlash = null;
          } else {
            boatCtx.save();
            boatCtx.translate(damageFlash.x, damageFlash.y);
            boatCtx.globalAlpha = damageFlash.opacity;
            boatCtx.drawImage(
              damageIconImage,
              -damageIconImage.width * damageIconScale / 2,  // Half of 1/10th width
              -damageIconImage.height * damageIconScale / 2, // Half of 1/10th height
              damageIconImage.width * damageIconScale,   // 1/10th of original width
              damageIconImage.height * damageIconScale   // 1/10th of original height
            );
            boatCtx.restore();
          }
        }
      }
    }

    // Update the click handler to add damage flash
    boatCanvas.addEventListener('click', (event) => {
      const rect = boatCanvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;
      
      let clickedBoat = false;
      
      // Check boss ship first
      if (bossShip && !bossShip.sinking && !bossShip.isFlotsam) {
        const boatWidth = bossShipImage.width * bossShip.size;
        const boatHeight = bossShipImage.height * bossShip.size;
        
        if (clickX >= bossShip.x && 
            clickX <= bossShip.x + boatWidth &&
            clickY >= bossShip.y && 
            clickY <= bossShip.y + boatHeight) {
          bossShip.damage++;

          // Add damage flash at click position
          damageFlash = {
            x: clickX,
            y: clickY,
            opacity: 1
          };

          if (bossShip.damage >= 20) {
            bossShip.sinkProgress = .13;
          }
          if (bossShip.damage >= 40) {
            bossShip.sinking = true;
            sailboats.forEach(boat => {
              if (!boat.sinking) {
                boat.sinking = true;
              }
            });
            sailboatSpawnProbability = 0.003; // Reset to initial spawn probability
          }
          
          clickedBoat = true;
        }
      }
      
      // Check regular boats if boss ship wasn't clicked
      if (!clickedBoat) {
        for (let sailboat of sailboats) {
          if (sailboat.sinking) continue; // Skip boats that are already sinking
          
          const boatWidth = sailboatImage.width * sailboat.size;
          const boatHeight = sailboatImage.height * sailboat.size;
          
          // Check if click is within boat bounds
          if (clickX >= sailboat.x && 
              clickX <= sailboat.x + boatWidth &&
              clickY >= sailboat.y && 
              clickY <= sailboat.y + boatHeight) {
            sailboat.sinking = true;
            clickedBoat = true;
            break; // Only sink one boat at a time
          }
        }
      }
      
      // If we didn't click a boat, let the event pass through
      if (!clickedBoat) {
        event.stopPropagation();
        event.preventDefault();
        // Re-dispatch the click event on the element below
        const elementBelow = document.elementFromPoint(event.clientX, event.clientY);
        if (elementBelow) {
          elementBelow.click();
        }
      }
    });

    document.body.addEventListener('mousemove', (event) => {
      const rect = boatCanvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      let hoveringBoat = false;
      
      // Check boss ship first
      if (bossShip && !bossShip.sinking && !bossShip.isFlotsam) {
        const boatWidth = bossShipImage.width * bossShip.size;
        const boatHeight = bossShipImage.height * bossShip.size;
        
        // Adjust mouse position check based on ship direction
        const adjustedX = bossShip.speedX > 0 ? 
          bossShip.x + boatWidth - (mouseX - bossShip.x) : // Flip X coordinate if ship is flipped
          mouseX;
        
        if (adjustedX >= bossShip.x && 
            adjustedX <= bossShip.x + boatWidth &&
            mouseY >= bossShip.y && 
            mouseY <= bossShip.y + boatHeight) {
          hoveringBoat = true;
        }
      }
      
      // Check regular boats if not hovering boss ship
      if (!hoveringBoat) {
        for (let sailboat of sailboats) {
          if (sailboat.sinking) continue;
          
          const boatWidth = sailboatImage.width * sailboat.size;
          const boatHeight = sailboatImage.height * sailboat.size;
          
          if (mouseX >= sailboat.x && 
              mouseX <= sailboat.x + boatWidth &&
              mouseY >= sailboat.y && 
              mouseY <= sailboat.y + boatHeight) {
            hoveringBoat = true;
            break;
          }
        }
      }
      
      // Update cursor and pointer events
      document.body.style.cursor = hoveringBoat ? 'pointer' : 'default';
      boatCanvas.style.pointerEvents = hoveringBoat ? 'auto' : 'none';
    });

    function spawnNewCloud() {
      const size = 0.3 + Math.random() * 0.5;
      const x = cloudCanvas.width + 50; // Start off-screen to the right
      clouds.push({
        x: x,
        y: Math.random() * document.documentElement.scrollHeight,
        size: size,
      });
    }

    // Add window resize and scroll handlers to update island bounds
    window.addEventListener('resize', () => {
      updateIslandBounds();
      updateAllCanvasSizes();
    });

    window.addEventListener('scroll', updateIslandBounds);
  </script>
</body>
</html> 