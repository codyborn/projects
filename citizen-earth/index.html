<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, orientation=portrait">
  <title>Citizen Earth</title>
  <style>
    html, body {
      height: 100%;
    }
    body {
      background: #4DD0E1;
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    #water-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      pointer-events: none;
      display: block;
    }
    #cloud-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 4;
      pointer-events: none;
      display: block;
    }
    #boat-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 3;
      pointer-events: none;
      display: block;
    }
    h1 {
      text-align: center;
      margin-top: 43px;
      font-size: 2.5rem;
      color: #222;
      z-index: 5;
      position: relative;
    }
    #sunk-ships-counter {
      position: fixed;
      top: 10px;
      right: 20px;
      background: rgba(44, 62, 80, 0.9);
      color: #fff;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 1.2rem;
      z-index: 9999;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      pointer-events: none;
    }
    .island-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      max-width: 1200px;
      margin-top: 40px;
      margin-bottom: 0px;
      margin-left: auto;
      margin-right: auto;

      direction: ltr;
    }
    .island {
      display: flex;
      flex-direction: column;
      align-items: center;
      border-radius: 18px;
      padding: 16px 8px 8px 8px;
      transition: transform 0.2s;
      cursor: pointer;
    }

    .island img {
      width: 120px;
      height: auto;
      margin-bottom: 12px;
      border-radius: 12px;
    }
    .city-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: #2a4d69;
      text-align: center;
      position: relative;
      z-index: 5;
    }
    @media (max-width: 900px) {
      .island-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 600px) {
      html {
        scroll-snap-type: y mandatory;
        scroll-behavior: smooth;
      }
      body {
        scroll-snap-type: y mandatory;
      }
      .island-grid {
        grid-template-columns: 1fr !important;
        justify-items: center;
        gap: 10vh;
        padding: 0 20px;
      }
      .island {
        grid-area: auto !important;
        scroll-snap-align: center;
        scroll-snap-stop: always;
        
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
    }
    .island-tooltip {
      background: rgba(44, 62, 80, 0.97);
      color: #fff;
      padding: 10px 16px;
      border-radius: 5px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.18);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
      z-index: 10;
      font-size: 1rem;
      margin-top: 1.5em;
    }
    .island {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .island-tooltip a {
      color: #ffd700;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <canvas id="water-canvas"></canvas>
  <canvas id="cloud-canvas"></canvas>
  <canvas id="boat-canvas"></canvas>
  <h1>Citizen Earth</h1>
  <div id="sunk-ships-counter">Ships Sunk: 0</div>
  <div class="island-grid" style="position:relative; z-index:2;">
    <!-- Islands will be inserted here by JS -->
  </div>
  <svg id="island-lines" style="position:absolute; top:0; left:0; pointer-events:none; z-index:1;"></svg>
  <footer style="position: fixed; bottom: 2px; width: 100%; text-align: center; opacity: 0.2; font-size: 0.8rem; color: #222;">
    Version 1.0.5
  </footer>
  <script>
    // Lock orientation to portrait on mobile devices
    if (window.innerWidth <= 600 && screen.orientation && screen.orientation.lock) {
      screen.orientation.lock('portrait').catch(() => {
        // Orientation lock not supported or failed
        console.log('Orientation lock not supported');
      });
    }

    // Water effect
    const waterCanvas = document.getElementById('water-canvas');
    const ctx = waterCanvas.getContext('2d');
    
    // Cloud system
    const cloudImage = new Image();
    cloudImage.src = './images/cloud.png';
    let clouds = [];
    const cloudSpeed = 0.1; // pixels per frame
    let islandBounds = []; // Store top and bottom Y values of each island
    const cloudSpawnProbability = 0.0004;
    
    // Sailboat system
    const sailboatImage = new Image();
    sailboatImage.src = './images/sailboat.png';
    let sailboats = [];
    const sailboatSpawnProbability = 0.002; // Reasonable spawn rate

    function checkSailboatOverlap(sailboatX, sailboatY, sailboatSize) {
      if (!sailboatImage.complete) return false;
      
      const sailboatWidth = sailboatImage.width * sailboatSize;
      const sailboatHeight = sailboatImage.height * sailboatSize;
      const sailboatBottom = sailboatY + sailboatHeight;
      const sailboatRight = sailboatX + sailboatWidth;
      
      // Add a buffer around islands (20 pixels)
      const buffer = 20;
      
      // Check if sailboat overlaps with any island
      for (let island of islandBounds) {
        if (sailboatX < island.right + buffer && sailboatRight > island.left - buffer &&
            sailboatY < island.bottom + buffer && sailboatBottom > island.top - buffer) {
          return true; // Overlap detected
        }
      }
      return false; // No overlap
    }
    
    function getValidSailboatPosition(sailboatSize) {
      const maxAttempts = 50; // More attempts since we're checking X and Y
      let attempts = 0;
      
      while (attempts < maxAttempts) {
        const randomX = Math.random() * boatCanvas.width;
        const randomY = Math.random() * boatCanvas.height; // Use full canvas height
        
        if (!checkSailboatOverlap(randomX, randomY, sailboatSize)) {
          return { x: randomX, y: randomY };
        }
        attempts++;
      }
      
      // If no valid position found, place at edge of screen
      const fallbackPositions = [
        { x: 50, y: boatCanvas.height * 0.2 },
        { x: boatCanvas.width - 100, y: boatCanvas.height * 0.4 },
        { x: boatCanvas.width * 0.5, y: boatCanvas.height * 0.6 },
        { x: 100, y: boatCanvas.height * 0.8 },
        { x: boatCanvas.width - 150, y: boatCanvas.height * 0.9 }
      ];
      
      // Try each fallback position
      for (let pos of fallbackPositions) {
        if (!checkSailboatOverlap(pos.x, pos.y, sailboatSize)) {
          return pos;
        }
      }
      
      // Last resort: place at safe edge position
      return { 
        x: Math.random() > 0.5 ? 50 : boatCanvas.width - 100, 
        y: Math.random() * boatCanvas.height // Use full canvas height
      };
    }
    
    function initializeSailboats() {
      sailboats = [];
      
      // Start with 2 sailboats on the page
      for (let i = 0; i < 2; i++) {
        const size = 0.4;
        const direction = Math.random() > 0.5 ? 1 : -1;
        const validPosition = getValidSailboatPosition(size);
        
        sailboats.push({
          x: validPosition.x,
          y: validPosition.y,
          size: size,
          speedX: (0.1 + Math.random() * 0.1) * direction,
          speedY: (Math.random() - 0.5) * 0.05,
          stopped: false,
          stopTimer: 0,
          originalSpeedX: (0.1 + Math.random() * 0.1) * direction,
          bobbingPhase: Math.random() * Math.PI * 2,
          sinking: false,
          rotation: 0,
          sinkProgress: 0
        });
      }
    }

    // Cloud canvas setup
    const cloudCanvas = document.getElementById('cloud-canvas');
    const cloudCtx = cloudCanvas.getContext('2d');
    
    function resizeCloudCanvas() {      
      cloudCanvas.width = Math.max(document.documentElement.scrollWidth, window.innerWidth);
      cloudCanvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight, document.body.offsetHeight);
    }
    
    // Boat canvas setup
    const boatCanvas = document.getElementById('boat-canvas');
    const boatCtx = boatCanvas.getContext('2d');
    
    function resizeBoatCanvas() {      
      boatCanvas.width = Math.max(document.documentElement.scrollWidth, window.innerWidth);
      boatCanvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight, document.body.offsetHeight);
    }
    
    function updateIslandBounds() {
      islandBounds = [];
      const islands = document.querySelectorAll('.island img');
      islands.forEach(img => {
        const rect = img.getBoundingClientRect();
        islandBounds.push({
          top: rect.top + window.scrollY,
          bottom: rect.bottom + window.scrollY,
          left: rect.left + window.scrollX,
          right: rect.right + window.scrollX
        });
      });
    }
    
    function initializeClouds() {
      clouds = [];
      const cloudCount = 5;
      for (let i = 0; i < cloudCount; i++) {
        const size = 0.3 + Math.random() * 0.5;
        const x = Math.random() * cloudCanvas.width;
        clouds.push({
          x: x,
          y: Math.random() * cloudCanvas.height, // Use full canvas height
          size: size,
        });
      }
    }
    
    function updateClouds() {
      // Random chance to spawn a new cloud each frame
      if (Math.random() < cloudSpawnProbability) {
        spawnNewCloud();
      }
      
      // Update existing clouds and remove those that have exited
      for (let i = clouds.length - 1; i >= 0; i--) {
        const cloud = clouds[i];
        cloud.x -= cloudSpeed;
        
        // Remove cloud if it has completely exited the left side
        if (cloud.x + cloudImage.width * cloud.size < 0) {
          clouds.splice(i, 1); // Delete the cloud
        }
      }
    }
    
    function drawClouds() {
      cloudCtx.clearRect(0, 0, cloudCanvas.width, cloudCanvas.height);
      
      if (cloudImage.complete) {
        clouds.forEach(cloud => {
          cloudCtx.save();
          cloudCtx.globalAlpha = 1.0;
          cloudCtx.drawImage(
            cloudImage,
            cloud.x,
            cloud.y,
            cloudImage.width * cloud.size,
            cloudImage.height * cloud.size
          );
          cloudCtx.restore();
        });
      }
    }
    
    function animateClouds() {
      updateClouds();
      drawClouds();
      requestAnimationFrame(animateClouds);
    }
    
    function animateBoats() {
      updateSailboats();
      drawSailboats();
      requestAnimationFrame(animateBoats);
    }
    
    function resizeWaterCanvas() {      
      waterCanvas.width = Math.max(document.documentElement.scrollWidth, window.innerWidth);
      waterCanvas.height = Math.max(document.documentElement.scrollHeight, window.innerHeight, document.body.offsetHeight);
    }
    
    function updateAllCanvasSizes() {
      resizeWaterCanvas();
      resizeCloudCanvas(); 
      resizeBoatCanvas();
    }
    
    function drawWater(time) {
      ctx.clearRect(0, 0, waterCanvas.width, waterCanvas.height);
      // Base water color - teal/turquoise
      ctx.fillStyle = '#4DD0E1';
      ctx.fillRect(0, 0, waterCanvas.width, waterCanvas.height);
      
      // Draw subtle crescent wave lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineCap = 'round';
      
      for (let i = 0; i < 15; i++) {
        ctx.beginPath();
        ctx.lineWidth = 2;
        
        // Create crescent shapes at different positions with independent movement
        const baseX = (i / 15) * waterCanvas.width + Math.sin(i * 1.7) * (waterCanvas.width * 0.2);
        
        // Calculate Y position with downward movement
        const waveSpeed = 0.005; // Speed of downward movement
        const waveHeight = waterCanvas.height + 100; // Extra height for smooth transition
        const baseY = ((time * waveSpeed) + (i * 80)) % waveHeight;
        
        const xCenter = baseX;
        const crescentWidth = 20 + Math.sin(i * 0.3) * 2;
        const crescentHeight = 3 + Math.sin(i * 0.7) * .7;
        
        // Draw crescent curve with shadow for dimension
        const alpha = 0.2 + Math.sin(i * 0.5 + time * 0.001) * 0.1;
        
        // First draw the shadow (darker, offset down)
        ctx.beginPath();
        for (let t = -Math.PI * 0.4; t <= Math.PI * 0.4; t += 0.05) {
          const x = xCenter + Math.sin(t) * crescentWidth;
          const y = baseY + Math.cos(t * 2) * crescentHeight + 2; // Offset shadow down by 2px
          
          if (t === -Math.PI * 0.4) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.strokeStyle = `rgba(0, 50, 80, ${alpha * 0.6})`; // Dark blue-gray shadow
        ctx.stroke();
        
        // Then draw the main line (white, on top)
        ctx.beginPath();
        for (let t = -Math.PI * 0.4; t <= Math.PI * 0.4; t += 0.05) {
          const x = xCenter + Math.sin(t) * crescentWidth;
          const y = baseY + Math.cos(t * 2) * crescentHeight;
          
          if (t === -Math.PI * 0.4) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.lineWidth = 4;
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.stroke();
      }
      
      requestAnimationFrame(drawWater);
    }
    requestAnimationFrame(drawWater);
    
    // Start cloud animation
    requestAnimationFrame(animateClouds);
    
    // Start boat animation
    requestAnimationFrame(animateBoats);

    // Placeholder cities with metadata
    const cities = [
      { 
        name: 'Miami',
        dates: 'Jan - Apr',
        duration: '3 months',
        islandImg: './images/miami.png',
        link: 'https://mirror.xyz/citizenearth.eth/mdQHEpgT3U0ZLge1NOm4xoMebfHwoaREPSYK3GIOdSc',
        linkText: 'Tied down'
      },
      { 
        name: 'New York', 
        dates: 'Apr', 
        duration: '1 month',
        islandImg: './images/NY.png',
        size: 200
      },
      { 
        name: 'Madrid', 
        dates: 'Apr - May', 
        duration: '1 week',
        islandImg: './images/madrid.png' ,
        size: 150
      },
      { 
        name: 'Granada', 
        dates: 'May', 
        duration: '2 weeks',
        islandImg: './images/granada.png' ,
        size: 200
      },
      { 
        name: 'Hyeres', 
        dates: 'May - Jun', 
        duration: '1 month',
        islandImg: './images/hyeres.png',
        size: 160
      },
      { 
        name: 'Antibes', 
        dates: 'Jun', 
        duration: '3 weeks',
        islandImg: './images/antibes.png',
        size: 160
      },
    ];

    // Responsive grid: let CSS handle columns, JS figures out columns dynamically
    const grid = document.querySelector('.island-grid');
    const svg = document.getElementById('island-lines');
    function getColumnCount() {
      const style = window.getComputedStyle(grid);
      const templateColumns = style.getPropertyValue('grid-template-columns');
      return templateColumns.split(' ').length;
    }

    let canvasesInitialized = false;
    function renderIslands() {
      grid.innerHTML = '';
      const cols = getColumnCount();
      const rows = Math.ceil(cities.length / cols);
      const positions = [];
      cities.forEach((cityObj, i) => {
        const row = Math.floor(i / cols);
        let col = i % cols;
        if (row % 2 === 1) col = cols - 1 - col;
        const div = document.createElement('div');
        div.className = 'island';
        div.style.gridRow = (row + 1).toString();
        div.style.gridColumn = (col + 1).toString();
        div.innerHTML = `
          <img src="${cityObj.islandImg}" alt="${cityObj.name}" style="width: ${cityObj.size ? cityObj.size + 'px' : '120px'}; height: auto;">
          <div class="city-name">${cityObj.name}</div>
          <div class="island-tooltip">
            <div><strong>${cityObj.duration}</strong></div>
            <div>${cityObj.dates}</div>
            ${cityObj.link ? `<div><a href="${cityObj.link}" target="_blank">${cityObj.linkText}</a></div>` : ''}
          </div>
        `;
        positions.push({row, col, div});
        // Tooltip show/hide
        div.addEventListener('mouseenter', () => {
          div.querySelector('.island-tooltip').style.opacity = 1;
        });
        div.addEventListener('mouseleave', () => {
          div.querySelector('.island-tooltip').style.opacity = 0;
        });
        grid.appendChild(div);
      });
      setTimeout(updateIslandBounds, 100); // Update island bounds after layout is complete
      setTimeout(() => {
        drawLines(positions, cols, rows);
        setupMobileTooltips(); // Setup mobile tooltip auto-display
        if (!canvasesInitialized) {
          canvasesInitialized = true;
          updateAllCanvasSizes();
          initializeClouds();
          initializeSailboats();
        }
      }, 300); // Increased delay to ensure content is fully rendered

      document.addEventListener('DOMContentLoaded', () => {
        drawLines(positions, cols, rows);
      });
    }

    function drawLines(positions, cols, rows) {
      svg.innerHTML = '';
      svg.setAttribute('width', document.body.scrollWidth);
      svg.setAttribute('height', document.body.scrollHeight);
      // Get center positions of each island image
      const centers = positions.map(({div}) => {
        const img = div.querySelector('img');
        const rect = img.getBoundingClientRect();
        return {
          x: rect.left + rect.width/2 + window.scrollX,
          y: rect.top + rect.height/2 + window.scrollY
        };
      });
      for (let i = 0; i < centers.length - 1; i++) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', centers[i].x);
        line.setAttribute('y1', centers[i].y);
        line.setAttribute('x2', centers[i+1].x);
        line.setAttribute('y2', centers[i+1].y);
        line.setAttribute('stroke', 'rgba(255, 255, 255, 0.5)');
        line.setAttribute('stroke-width', '4');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('stroke-dasharray', '8,8');
        svg.appendChild(line);
      }
    }
    // Set grid-template-columns to be responsive
    grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(180px, 1fr))';
    window.addEventListener('resize', renderIslands);
    renderIslands();

    // Mobile tooltip auto-display functionality
    function setupMobileTooltips() {
      // Check if device is mobile
      const isMobile = window.innerWidth <= 600;
      if (!isMobile) return;

      const islands = document.querySelectorAll('.island');
      const firstIsland = islands[0];
      const lastIsland = islands[islands.length - 1];

      // Create intersection observer for center screen detection
      const observerOptions = {
        root: null,
        rootMargin: '-30% 0px -30% 0px', // Only trigger when in center 40% of screen
        threshold: 0.5
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const tooltip = entry.target.querySelector('.island-tooltip');
          if (entry.isIntersecting) {
            // Island is in center area - show tooltip
            tooltip.style.opacity = '1';
            tooltip.style.transform = 'translateY(-10px)';
          } else {
            // Island is outside center area - hide tooltip
            tooltip.style.opacity = '0';
            tooltip.style.transform = 'translateY(0)';
          }
        });
      }, observerOptions);

      // Observe all islands
      islands.forEach(island => {
        observer.observe(island);
      });

      // Handle scroll for first/last island edge cases
      function handleScroll() {
        const scrollY = window.scrollY;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        
        // Show first island tooltip when at top of page
        if (scrollY <= 50) { // Within 50px of top
          const firstTooltip = firstIsland.querySelector('.island-tooltip');
          firstTooltip.style.opacity = '1';
          firstTooltip.style.transform = 'translateY(-10px)';
        }
        
        // Show last island tooltip when at bottom of page
        if (scrollY + windowHeight >= documentHeight - 50) { // Within 50px of bottom
          const lastTooltip = lastIsland.querySelector('.island-tooltip');
          lastTooltip.style.opacity = '1';
          lastTooltip.style.transform = 'translateY(-10px)';
        }
      }

      // Add scroll listener
      window.addEventListener('scroll', handleScroll);
      
      // Initial check
      handleScroll();
    }

    let totalSunkShips = 0;
    const sunkShipsCounter = document.getElementById('sunk-ships-counter');

    function updateSunkShipsCounter() {
      if (totalSunkShips > 0) {
        sunkShipsCounter.style.display = 'block';
        sunkShipsCounter.textContent = `Ships Sunk: ${totalSunkShips}`;
      } else {
        sunkShipsCounter.style.display = 'none';
      }
    }

    function updateSailboats() {
      // Random chance to spawn a new sailboat each frame
      if (Math.random() < sailboatSpawnProbability) {
        spawnNewSailboat();
      }
      
      // Update existing sailboats and remove those that have exited
      for (let i = sailboats.length - 1; i >= 0; i--) {
        const sailboat = sailboats[i];
        
        if (sailboat.sinking) {
            sailboat.speedX = sailboat.speedX * .99
            // Update sinking animation
            const sinkSpeed = 0.002;
            sailboat.sinkProgress += sinkSpeed; // Speed of sinking
            // lower boat into water
            sailboat.y += sinkSpeed * sailboat.size * sailboatImage.height;
            
            // Remove boat once fully sunk
            if (sailboat.sinkProgress >= 1) {
              totalSunkShips++;
              updateSunkShipsCounter();
              sailboats.splice(i, 1);
              continue;
            }
          }

        if (sailboat.stopped) {
          // Boat is stopped at island - only bob up and down
          sailboat.stopTimer++;
          sailboat.y += Math.sin(sailboat.stopTimer * 0.03 + sailboat.bobbingPhase) * 0.02;
          
          // After 5 seconds, resume sailing
          if (sailboat.stopTimer >= 300) {
            sailboat.stopped = false;
            sailboat.stopTimer = 0;
            sailboat.speedX = -sailboat.originalSpeedX; // Reverse direction
            sailboat.speedY = (Math.random() - 0.5) * 0.05;
          }
        } else {
          // Normal sailing behavior
          const prevX = sailboat.x;
          const prevY = sailboat.y;
          
          // Update position
          sailboat.x += sailboat.speedX;
          sailboat.y += sailboat.speedY;
          
          // Check for collision with islands and stop if needed
          if (checkSailboatOverlap(sailboat.x, sailboat.y, sailboat.size)) {
            sailboat.x = prevX;
            sailboat.y = prevY;
            sailboat.stopped = true;
            sailboat.stopTimer = 0;
          }
          
          // Bounce off top and bottom edges
          if (sailboat.y < 0) {
            sailboat.y = 0;
            sailboat.speedY = Math.abs(sailboat.speedY);
          }
          if (sailboat.y + sailboatImage.height * sailboat.size > boatCanvas.height) {
            sailboat.y = boatCanvas.height - sailboatImage.height * sailboat.size;
            sailboat.speedY = -Math.abs(sailboat.speedY);
          }
        }
        
        // Remove sailboat if it has completely exited the screen
        if (!sailboat.sinking && (sailboat.x + sailboatImage.width * sailboat.size < 0 || sailboat.x > boatCanvas.width)) {
          sailboats.splice(i, 1);
        }
      }
    }
    
    function drawSailboats() {
      boatCtx.clearRect(0, 0, boatCanvas.width, boatCanvas.height);
      
      if (sailboatImage.complete) {
        // Sort sailboats by Y position (lower Y drawn first, higher Y drawn last = in front)
        const sortedSailboats = [...sailboats].sort((a, b) => a.y - b.y);
        
        sortedSailboats.forEach(sailboat => {
          boatCtx.save();
          
          // Calculate center point for rotation
          const centerX = sailboat.x + (sailboatImage.width * sailboat.size) / 2;
          const centerY = sailboat.y + (sailboatImage.height * sailboat.size) / 2;
          
          // Move to center point for rotation
          boatCtx.translate(centerX, centerY);
          
          // Calculate clipping for sinking animation
          if (sailboat.sinking) {
            const clipHeight = sailboatImage.height * sailboat.size * (1 - sailboat.sinkProgress);
            boatCtx.beginPath();
            boatCtx.rect(-(sailboatImage.width * sailboat.size) / 2, 
                        -(sailboatImage.height * sailboat.size) / 2,
                        sailboatImage.width * sailboat.size,
                        clipHeight);
            boatCtx.clip();
          }
          
          // Draw the boat
          boatCtx.drawImage(
            sailboatImage,
            -(sailboatImage.width * sailboat.size) / 2,
            -(sailboatImage.height * sailboat.size) / 2,
            sailboatImage.width * sailboat.size,
            sailboatImage.height * sailboat.size
          );
          
          boatCtx.restore();
        });
      }
    }

    // Add click detection for boats
    boatCanvas.addEventListener('click', (event) => {
      const rect = boatCanvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;
      
      // Check each boat for click
      let clickedBoat = false;
      for (let sailboat of sailboats) {
        if (sailboat.sinking) continue; // Skip boats that are already sinking
        
        const boatWidth = sailboatImage.width * sailboat.size;
        const boatHeight = sailboatImage.height * sailboat.size;
        
        // Check if click is within boat bounds
        if (clickX >= sailboat.x && 
            clickX <= sailboat.x + boatWidth &&
            clickY >= sailboat.y && 
            clickY <= sailboat.y + boatHeight) {
          sailboat.sinking = true;
          sailboat.sinkProgress = 0;
          clickedBoat = true;
          break; // Only sink one boat at a time
        }
      }
      
      // If we didn't click a boat, let the event pass through
      if (!clickedBoat) {
        event.stopPropagation();
        event.preventDefault();
        // Re-dispatch the click event on the element below
        const elementBelow = document.elementFromPoint(event.clientX, event.clientY);
        if (elementBelow) {
          elementBelow.click();
        }
      }
    });

    document.body.addEventListener('mousemove', (event) => {
      const rect = boatCanvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      let hoveringBoat = false;
      for (let sailboat of sailboats) {
        if (sailboat.sinking) continue;
        
        const boatWidth = sailboatImage.width * sailboat.size;
        const boatHeight = sailboatImage.height * sailboat.size;
        
        if (mouseX >= sailboat.x && 
            mouseX <= sailboat.x + boatWidth &&
            mouseY >= sailboat.y && 
            mouseY <= sailboat.y + boatHeight) {
          hoveringBoat = true;
          // change cursor to pointer
          document.body.style.cursor = 'pointer';
          break;
        }
      }
      if (!hoveringBoat) {
        document.body.style.cursor = 'default';
      }
      
      boatCanvas.style.pointerEvents = hoveringBoat ? 'auto' : 'none';
    });

    function spawnNewCloud() {
      const size = 0.3 + Math.random() * 0.5;
      const x = cloudCanvas.width + 50; // Start off-screen to the right
      clouds.push({
        x: x,
        y: Math.random() * document.documentElement.scrollHeight,
        size: size,
      });
    }

    function spawnNewSailboat() {
      // Only spawn if image is loaded
      if (!sailboatImage.complete) return;
      
      const size = 0.4;
      const direction = Math.random() > 0.5 ? 1 : -1; // Random left or right
      const boatWidth = sailboatImage.width * size;
      const x = direction === 1 ? -boatWidth : boatCanvas.width + boatWidth;
      
      // Get a valid Y position that doesn't overlap with islands
      const validPosition = getValidSailboatPosition(size);
      
      sailboats.push({
        x: x,
        y: validPosition.y,
        size: size,
        speedX: (0.1 + Math.random() * 0.1) * direction,
        speedY: (Math.random() - 0.5) * 0.05,
        stopped: false,
        stopTimer: 0,
        originalSpeedX: (0.1 + Math.random() * 0.1) * direction,
        bobbingPhase: Math.random() * Math.PI * 2,
        sinking: false,
        rotation: 0,
        sinkProgress: 0
      });
    }

    // Add window resize and scroll handlers to update island bounds
    window.addEventListener('resize', () => {
      updateIslandBounds();
      updateAllCanvasSizes();
    });

    window.addEventListener('scroll', updateIslandBounds);
  </script>
</body>
</html> 